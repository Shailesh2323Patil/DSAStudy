Array :
=======

Que 1 : Set Matrix Zeros (Striver SDE Sheet)
Level : Medium
Link : https://takeuforward.org/data-structure/set-matrix-zero/
------------------------
Examples 1:

Input: matrix=[[1,1,1],[1,0,1],[1,1,1]]

Output: [[1,0,1],[0,0,0],[1,0,1]]

Explanation: Since matrix[2][2]=0. Therefor the 2nd column and 2nd row wil be set to 0.

Input: matrix=[[0,1,2,0],[3,4,5,2],[1,3,1,5]]

Output:[[0,0,0,0],[0,4,5,0],[0,3,1,0]]

Explanation:Since matrix[0][0]=0 and matrix[0][3]=0. Therefore 1st row, 1st column and 4th column will be set to 0

Brute Force Approach
--------------------

Approach:
The steps are the following:

1. First, we will use two loops(nested loops) to traverse all the cells of the matrix.
2. If any cell (i,j) contains the value 0, we will mark all cells in row i and column j with -1 except
those which contain 0.
3. We will perform step 2 for every cell containing 0.
4. Finally, we will mark all the cells containing -1 with 0.
5. Thus the given matrix will be modified according to the question.
Note: Here, we are assuming that the matrix does not contain any negative numbers. But if it contains negatives,
we need to find some other ways to mark the cells instead of marking them with -1.

Program :
import java.util.ArrayList;
import java.util.Arrays;

public class SetMatrixZerosBruteForce {

    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
        matrix.add(new ArrayList<>(Arrays.asList(1,1,1)));
        matrix.add(new ArrayList<>(Arrays.asList(1,0,1)));
        matrix.add(new ArrayList<>(Arrays.asList(1,1,1)));

        // Checking Initial Matrix
        System.out.println("The Matrix :");
        for(ArrayList<Integer> row : matrix) {
            for (Integer element : row) {
                System.out.print(element + " ");
            }
            System.out.println();
        }

        int rows = matrix.size();
        int cols = matrix.get(0).size();

        ArrayList<ArrayList<Integer>> answer = setZeroMatrix(matrix, rows, cols);

        // Checking Final Matrix
        System.out.println("The Final Matrix : ");
        for(ArrayList<Integer> row : answer) {
            for(Integer element : row) {
                System.out.print(element + " ");
            }
            System.out.println();
        }
    }

    public static ArrayList<ArrayList<Integer>> setZeroMatrix(ArrayList<ArrayList<Integer>> matrix,
        int mRowSize, int mColSize)
    {
        // Find the Element Which Has 0
        for(int row=0; row<mRowSize; row++) {
            for(int col=0; col<mColSize; col++) {
                if(matrix.get(row).get(col) == 0) {
                    // Set Row Element as -1
                    markRow(matrix, mRowSize, row);
                    // Set Column Element as -1
                    markCol(matrix, mColSize, col);
                }
            }
        }

        // Mark All -1 as 0
        for(int row=0; row<mRowSize; row++) {
            for(int col=0; col<mColSize; col++) {
                if(matrix.get(row).get(col) == -1) {
                    matrix.get(row).set(col, 0);
                }
            }
        }

        return matrix;
    }

    // Mark Total Row as -1
    public static void markRow(ArrayList<ArrayList<Integer>> matrix, int size, int row) {
        for (int i=0; i<size; i++) {
            if(matrix.get(row).get(i) != 0) {
                matrix.get(row).set(i, -1);
            }
        }
    }

    // Mark Total Col as -1
    public static void markCol(ArrayList<ArrayList<Integer>> matrix, int size, int col) {
        for(int j=0; j<size; j++) {
            if(matrix.get(j).get(col) != 0) {
                matrix.get(j).set(col, -1);
            }
        }
    }
}

Complexity Analysis
-----------------
Time Complexity: O((N*M)*(N+M))+O(N*M),
where N = no. of rows in the matrix and M = no. of columns in the matrix.
Reason: Firstly, we are traversing the matrix to find the cells with the value 0.
It takes O(N*M).
Now, whenever we find any such cell we mark that row and column with -1.
This process takes O(N+M).
So, combining this the whole process, finding and marking, takes O((N*M)*(N + M)).
Another O(N*M) is taken to mark all the cells with -1 as 0 finally.

Space Complexity: O(1) as we are not using any extra space.


Better Approach :
-----------------

Algorithm / Intuition
In the previous approach, we were marking the row and column with -1 while traversing the matrix.
Here we will reduce the time complexity by marking the cells after the traversal.

Approach (Using two extra arrays):
The steps are as follows:

1. First, we will declare two arrays: a row array of size N and a col array of size M and both are
   initialized with 0.
2. Then, we will use two loops(nested loops) to traverse all the cells of the matrix.
3. If any cell (i,j) contains the value 0, we will mark ith index of row array i.e. row[i] and jth
   index of col array col[j] as 1. It signifies that all the elements in the ith row and jth column will
   be 0 in the final matrix.
4. We will perform step 3 for every cell containing 0.
5. Finally, we will again traverse the entire matrix and we will put 0 into all the cells (i, j) for
   which either row[i] or col[j] is marked as 1.
6. Thus we will get our final matrix.

Program :
import java.util.ArrayList;
import java.util.Arrays;

public class SetMatrixZerosBetterApproach {
    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> matrix = new ArrayList<ArrayList<Integer>>();

        matrix.add(new ArrayList<>(Arrays.asList(1,1,1)));
        matrix.add(new ArrayList<>(Arrays.asList(1,0,1)));
        matrix.add(new ArrayList<>(Arrays.asList(1,1,1)));

        System.out.println("The Initial Matrix : ");

        for (ArrayList<Integer> data : matrix) {
            for(Integer element : data) {
                System.out.print(element + " ");
            }
            System.out.println();
        }

        int rows = matrix.size();
        int cols = matrix.get(0).size();

        System.out.println("The Final Matrix : ");
        ArrayList<ArrayList<Integer>> answer = setMatrixZero(matrix, rows, cols);

        for (ArrayList<Integer> row  : answer) {
            for (Integer element : row) {
                System.out.print(element +" ");
            }
            System.out.println();
        }
    }

    public static ArrayList<ArrayList<Integer>> setMatrixZero(ArrayList<ArrayList<Integer>> matrix,
        int rowSize, int colSize)
    {
        // Set the UpperRow Array & SideColumn Array
        int[] upperRow = new int[rowSize];
        int[] sideCol = new int[colSize];

        // Set All UpperRow and SideCol as 1, If we found matrix(row, col) as 0
        for(int row=0; row<rowSize; row++) {
            for(int col=0; col<colSize; col++) {
                if(matrix.get(row).get(col) == 0) {
                    upperRow[row] = 1;
                    sideCol[col] = 1;
                }
            }
        }

        // Set matrix(row, col) as 0, If we Found UpperRow or SideCol as 1
        for(int row=0; row<rowSize; row++) {
            for (int col=0; col<colSize; col++) {
                if(upperRow[row] == 1 || sideCol[col] == 1) {
                    matrix.get(row).set(col, 0);
                }
            }
        }

        return matrix;
    }
}

Output :
The Initial Matrix :
1 1 1
1 0 1
1 1 1
The Final Matrix :
1 0 1
0 0 0
1 0 1

Complexity Analysis :
Time Complexity: O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.
Reason: We are traversing the entire matrix 2 times and each traversal is taking O(N*M) time complexity.

Space Complexity: O(N) + O(M), where N = no. of rows in the matrix and M = no. of columns in the matrix.
Reason: O(N) is for using the row array and O(M) is for using the col array.


Optimal Approach :
------------------

Intuition:
----------
In the previous approach, the time complexity is minimal as the traversal of a matrix takes at least
O(N*M)(where N = row and M = column). In this approach, we can just improve the space complexity.
So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the
given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem.
If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken
twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st
row of the matrix will serve the purpose of the row array. And the 1st column from (0,1) to (0,m-1)
with the col0 variable will serve the purpose of the col array.

If any cell in the 0th row contains 0, we will mark matrix[0][0] as 0 and if any cell in the 0th column
contains 0, we will mark the col0 variable as 0.

Thus we can optimize the space complexity.

Approach:
---------

The steps are as follows:

1. First, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0
accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e.
matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.
If i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead
of marking matrix[0][0] again.
2. After step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from
the 1st row, 1st column, and col0 variable.
We will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the
matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.
3. Finally, we will change the 1st row and column using the values from matrix[0][0] and col0
variable. Here also we will change the row first and then the column.
If matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.
If col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0.

Program :

import java.util.ArrayList;
import java.util.Arrays;

public class SetMatrixZerosOptimalApproach {
    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> matrix = new ArrayList<ArrayList<Integer>>();
        matrix.add(new ArrayList<>(Arrays.asList(1,1,1,1)));
        matrix.add(new ArrayList<>(Arrays.asList(1,0,1,1)));
        matrix.add(new ArrayList<>(Arrays.asList(1,1,0,1)));
        matrix.add(new ArrayList<>(Arrays.asList(0,1,1,1)));

        System.out.println("The Initial Array : ");
        for(ArrayList<Integer> arrayList : matrix) {
            for(Integer element : arrayList) {
                System.out.print(element+" ");
            }
            System.out.println();
        }

        int rows = matrix.size();
        int cols = matrix.get(0).size();

        ArrayList<ArrayList<Integer>> answer = setMatrixZeros(matrix, rows, cols);

        System.out.println("The Final Array : ");
        for(ArrayList<Integer> arrayList : answer) {
            for(Integer element : arrayList) {
                System.out.print(element+" ");
            }
            System.out.println();
        }
    }

    public static ArrayList<ArrayList<Integer>> setMatrixZeros(ArrayList<ArrayList<Integer>> matrix, int rowSize, int colSize) {

        int col0 = 1;

        for(int row=0; row<rowSize; row++) {
            for(int col=0; col<colSize; col++) {
                if(matrix.get(row).get(col) == 0) {
                    matrix.get(row).set(0,0);

                    if(col != 0) {
                        matrix.get(0).set(col, 0);
                    }
                    else {
                        col0 = 0;
                    }
                }
            }
        }

        for(int row=1; row<rowSize; row++) {
            for(int col=1; col<colSize; col++) {
                // Check the Position matrix.get(row, col) is non 0
                if(matrix.get(row).get(col) != 0) {
                    // check the current Row's Oth Element is 0 OR
                    // check the current Col's Oth Element is 0
                    if(matrix.get(row).get(0) == 0 || matrix.get(0).get(col) == 0) {
                        matrix.get(row).set(col, 0);
                    }
                }
            }
        }

        // Check for first Row's (0,0) is 0 to mark all 0
        if(matrix.get(0).get(0) == 0) {
            // it travers in total column's
            for(int i=0; i<colSize; i++) {
                // marking every element of first row as 0
                matrix.get(0).set(i, 0);
            }
        }

        // Check for col0 is 0 to mark first Column
        if(col0 == 0) {
            // it travers in total row's
            for (int i=0; i<rowSize; i++) {
                // marking every element of first colum as 0
                matrix.get(i).set(0, 0);
            }
        }

        return matrix;
    }
}

Output :
The Initial Array :
1 1 1 1
1 0 1 1
1 1 0 1
0 1 1 1
The Final Array :
0 0 0 1
0 0 0 0
0 0 0 0
0 0 0 0

Complexity Analysis :
Time Complexity: O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.
Reason: In this approach, we are also traversing the entire matrix 2 times and each traversal is taking
        O(N*M) time complexity.

Space Complexity: O(1) as we are not using any extra space.


---------------------------------------XXX-----------------------------------------------

Que 2 : next_permutation : find next lexicographically greater permutation
Level : Medium
Link : https://takeuforward.org/data-structure/next_permutation-find-next-lexicographically-greater-permutation/

Example 1 :
---------
Input format: Arr[] = {1,3,2}
Output: Arr[] = {2,1,3}
Explanation: All permutations of {1,2,3} are {{1,2,3} , {1,3,2}, {2,13} , {2,3,1} , {3,1,2} , {3,2,1}}.
So, the next permutation just after {1,3,2} is {2,1,3}.

Input format: Arr[] = {3,2,1}
Output: Arr[] = {1,2,3}
Explanation: As we see all permutations of {1,2,3}, we find {3,2,1} at the last position.
So, we have to return the topmost permutation.

Brute Force Approach :
--------------------

Algorithm / Intuition
Brute Force: Finding all possible permutations.

Approach :

Step 1: Find all possible permutations of elements present and store them.

Step 2: Search input from all possible permutations.

Step 3: Print the next permutation present right after it.

For reference of how to find all possible permutations,
follow up https://www.youtube.com/watch?v=f2ic2Rsc9pU&t=32s.
This video shows for distinct elements but code works for duplicates too.

Complexity Analysis
For finding, all possible permutations, it is taking N!xN. N represents the number of elements present
in the input array. Also for searching input arrays from all possible permutations will take N!.
Therefore, it has a Time complexity of O(N!xN).

Space Complexity :
Since we are not using any extra spaces except stack spaces for recursion calls.
So, it has a space complexity of O(1).

Optimal Approach :
-----------------

Algorithm / Intuition
The steps are the following:

1.  Find the break-point, i: Break-point means the first index i from the back of the given array where
    arr[i] becomes smaller than arr[i+1].
    For example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing).
    Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.
    To find the break-point, using a loop we will traverse the array backward and store the index i where arr[i]
    is less than the value at index (i+1) i.e. arr[i+1].
2.  If such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation
    is the last one in the sorted order of all possible permutations. So, the next permutation must be the
    first i.e. the permutation in increasing order.
    So, in this case, we will reverse the whole array and will return it as our answer.
3.  If a break-point exists:
    3.1 Find the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1)
    and swap it with arr[i].
    3.2 Reverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.

Program :
--------

public class NextPermutations {
    public static List<Integer> nextGreaterPermutation(List<Integer> list) {
        int n = list.size();
        int breakIndex = -1;

        // Find the BreakIndex
        for(int i=n-2; i>=0; i--) {
            if(list.get(i) < list.get(i+1)) {
                breakIndex = i;
                break;
            }
        }

        // If BreakIndex is -1 then reverse a List
        if(breakIndex == -1) {
            Collections.reverse(list);
            return list;
        }

        // Find Out the Next Greater Element Of BreakIndex
        for(int i=n-1; i>breakIndex; i--) {
            if(list.get(i) > list.get(breakIndex)) {
                int temp = list.get(breakIndex);
                list.set(breakIndex, list.get(i));
                list.set(i, temp);
                break;
            }
        }

        // Revers Remaining Element
        List<Integer> sublist = list.subList(breakIndex+1, n);

        Collections.reverse(sublist);

        return list;
    }

    public static void main(String args[]) {
        List<Integer> A = Arrays.asList(new Integer[] {1,2,3});
        List<Integer> ans = nextGreaterPermutation(A);

        System.out.print("The next permutation is: [");
        for (int i = 0; i < ans.size(); i++) {
            System.out.print(ans.get(i) + " ");
        }
        System.out.println("]");
    }
}


Complexity Analysis :
---------------------
Time Complexity: O(3N), where N = size of the given array
Finding the break-point, finding the next greater element, and reversal at the end takes O(N) for each,
where N is the number of elements in the input array. This sums up to 3*O(N) which is approximately O(3N).

Space Complexity: Since no extra storage is required. Thus, its space complexity is O(1).

Output : The next permutation is: [1 3 2]

---------------------------------------XXX-----------------------------------------------

Que 3 : Kadane’s Algorithm : Maximum Subarray Sum in an Array
Level : Medium
Link : https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/

Problem Statement: Given an integer array arr, find the contiguous subarray (containing at least
one number) which has the largest sum and returns its sum and prints the subarray.

Example 1:

Input: arr = [-2,1,-3,4,-1,2,1,-5,4]

Output: 6

Explanation: [4,-1,2,1] has the largest sum = 6.

Examples 2:

Input: arr = [1]

Output: 1

Explanation: Array has only one element and which is giving positive sum of 1.

Brute Force Approach
--------------------

Intuition:
----------
We will check the sum of every possible subarray and consider the maximum among them.
To get every possible subarray sum, we will be using three nested loops.
The first loops(say i and j) will iterate over every possible starting index and ending index of a subarray.
Basically, in each iteration, the subarray range will be from index i to index j.
Using another loop we will get the sum of the elements of the subarray [i…..j]. Among all values of the sum calculated,
we will consider the maximum one.

Approach:
The steps are as follows:

1.  First, we will run a loop(say i) that will select every possible starting index of the subarray.
    The possible starting indices can vary from index 0 to index n-1(n = size of the array).
2.  Inside the loop, we will run another loop(say j) that will signify the ending index of the subarray.
    For every subarray starting from the index i, the possible ending index can vary from index i to n-1(n = size of the array).
3.  After that for each subarray starting from index i and ending at index j (i.e. arr[i….j]),
    we will run another loop to calculate the sum of all the elements(of that particular subarray).

    Note: We are selecting every possible subarray using two nested loops and for each of them,
    we add all its elements using another loop.

Program :
---------

public class SubArraySumBruteForce {
    public static void main(String[] args) {
        int[] arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4};
        int n = arr.length;
        int maxSum = maxSubArraySum(arr, n);
        System.out.println("The maximum Sub Array sum is: " + maxSum);
    }

    static int maxSubArraySum(int[] arr, int size) {
        int maximum = Integer.MIN_VALUE;

        // Traverse from the Index by Index
        for(int i = 0; i < size; i++) {

            // Start Traverse From ith Index
            for(int j = i; j < size; j++) {
                // Initialise the sum variable
                int sum = 0;

                // Start traverse from ith Index to jth Index
                for(int k = i; k <= j; k++) {
                    sum += arr[k];
                }

                maximum = Math.max(sum, maximum);
            }
        }

        return maximum;
    }
}

Complexity Analysis
-------------------
Time Complexity: O(N^3), where N = size of the array.
Reason: We are using three nested loops, each running approximately N times.

Space Complexity: O(1) as we are not using any extra space.


Better Approach
----------------

Algorithm / Intuition

Intuition: If we carefully observe, we can notice that to get the sum of the current subarray we just
need to add the current element(i.e. arr[j]) to the sum of the previous subarray i.e. arr[i….j-1].

Assume previous subarray = arr[i……j-1]
current subarray = arr[i…..j]
Sum of arr[i….j] = (sum of arr[i….j-1]) + arr[j]

This is how we can remove the third loop and while moving j pointer, we can calculate the sum.

Approach:
The steps are as follows:

1.  First, we will run a loop(say i) that will select every possible starting index of the subarray.
    The possible starting indices can vary from index 0 to index n-1(n = array size).
2.  Inside the loop, we will run another loop(say j) that will signify the ending index as well as the
    current element of the subarray. For every subarray starting from index i, the possible ending index
    can vary from index i to n-1(n = size of the array).
3.  Inside loop j, we will add the current element to the sum of the previous subarray i.e. sum = sum + arr[j].
    Among all the sums the maximum one will be the answer.

Program :
---------

public class SubArraySumBetterApproach {
    public static void main(String[] args) {
        int[] arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4};
        int n = arr.length;
        int maxSum = maxSubArraySum(arr, n);
        System.out.println("The maximum Sub Array sum is: " + maxSum);
    }

    static int maxSubArraySum(int[] arr, int size) {
        int maximum = Integer.MIN_VALUE;

        for(int i = 0; i < size; i++) {
            int sum = 0;

            for(int j = i; j < size; j++) {
                // current subArray = arr[i.....j]

                //add the current element arr[j]
                // to the sum i.e. sum of arr[i...j-1]
                sum += arr[j];
                maximum = Math.max(sum, maximum);
            }
        }

        return maximum;
    }
}


Optimal Approach :
------------------

Algorithm / Intuition
Intuition:
The intuition of the algorithm is not to consider the subarray as a part of the answer if its sum is less than 0.
A subarray with a sum less than 0 will always reduce our answer and so this type of subarray cannot be a
part of the subarray with maximum sum.

Here, we will iterate the given array with a single loop and while iterating we will add the elements in
a sum variable. Now, if at any point the sum becomes less than 0, we will set the sum as 0 as we are not
going to consider any subarray with a negative sum. Among all the sums calculated, we will consider the maximum one.

Thus we can solve this problem with a single loop.

Approach:
The steps are as follows:

1.  We will run a loop(say i) to iterate the given array.
2.  Now, while iterating we will add the elements to the sum variable and consider the maximum one.
3.  If at any point the sum becomes negative we will set the sum to 0 as we are not going to consider
    it as a part of our answer.
    Note: In some cases, the question might say to consider the sum of the empty subarray while solving this problem.
    So, in these cases, before returning the answer we will compare the maximum subarray sum calculated
    with 0(i.e. The sum of an empty subarray is 0). And after that, we will return the maximum one.
    For e.g. if the given array is {-1, -4, -5}, the answer will be 0 instead of -1 in this case.

Program :
public class SubArraySumOptimalApproach {
    public static void main(String[] args) {
        int[] arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4};
        int n = arr.length;
        long maxSum = maxSubArraySum(arr, n);
        System.out.println("The maximum sub array sum is: " + maxSum);
    }

    static long maxSubArraySum(int[] arr, int size) {
        long maxNumber = Long.MIN_VALUE;
        long sum = 0;

        for(int i=0; i<size; i++) {
            sum += arr[i];

            if(sum > maxNumber) {
                maxNumber = sum;
            }

            // If sum < 0: discarded the calculated
            if(sum < 0) {
                sum = 0;
            }
        }

        // To consider the sum of the empty sub array
        // uncomment the following check:
//        if(maxNumber < 0) {
//            maxNumber = 0;
//        }

        return maxNumber;
    }
}


Optimal with Follow-up Question :
---------------------------------

Algorithm / Intuition
There might be more than one subarray with the maximum sum. We need to print any of them.

Intuition: Our approach is to store the starting index and the ending index of the subarray.
Thus we can easily get the subarray afterward without actually storing the subarray elements.

If we carefully observe our algorithm, we can notice that the subarray always starts at the particular
index where the sum variable is equal to 0, and at the ending index, the sum always crosses the previous maximum sum(i.e. maxi).

*   So, we will keep a track of the starting index inside the loop using a start variable.
*   We will take two variables ansStart and ansEnd initialized with -1. And when the sum crosses the maximum sum,
    we will set ansStart to the start variable and ansEnd to the current index i.e. i.
    The rest of the approach will be the same as Kadane’s Algorithm.

Program :
---------

public class SubArraySumOptimalApproachPrint {
    public static void main(String args[]) {
        int[] arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4};
        int n = arr.length;
        long maxSum = maxSubArraySum(arr, n);
        System.out.println("The maximum sub array sum is : " + maxSum);
    }

    static int maxSubArraySum(int[] arr, int size) {
        int sum = 0;
        int maxNumber = Integer.MIN_VALUE;

        int start = 0;
        int ansStart = -1;
        int ansEnd = -1;

        for(int i=0; i<size; i++)
        {
            if(sum == 0) {
                start = i;
            }

            sum += arr[i];

            if(sum > maxNumber) {
                maxNumber = sum;
                ansStart = start;
                ansEnd = i;
            }

            if(sum < 0) {
                sum = 0;
            }
        }

        System.out.print("The SubArray is = [ ");
        for(int i=ansStart; i<=ansEnd; i++) {
            System.out.print(arr[i]+" ");
        }
        System.out.println("]");

        return maxNumber;
    }
}

Output :
The SubArray is = [ 4 -1 2 1 ]
The maximum sub array sum is : 6

---------------------------------------XXX-----------------------------------------------

Que 4 : Sort an array of 0s, 1s and 2s
Level : Medium
Link : https://takeuforward.org/data-structure/sort-an-array-of-0s-1s-and-2s/

Examples
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Input: nums = [2,0,1]
Output: [0,1,2]

Input: nums = [0]
Output: [0]

Brute Force Approach :
----------------------

Algorithm / Intuition
---------------------
Sorting ( even if it is not the expected solution here but it can be considered as one of the approaches).
Since the array contains only 3 integers, 0, 1, and 2. Simply sorting the array would arrange the elements in increasing order.

Complexity Analysis
Time Complexity: O(N*logN)

Space Complexity: O(1)


Better Approach :
-----------------

Algorithm / Intuition
---------------------
Keeping count of values

Intuition: Since in this case there are only 3 distinct values in the array so it’s easy to maintain the
count of all, Like the count of 0, 1, and 2. This can be followed by overwriting the array based on the
frequency(count) of the values.

Approach:
--------

1.  Take 3 variables to maintain the count of 0, 1 and 2.
2.  Travel the array once and increment the corresponding counting variables

( let’s consider count_0 = a, count_1 = b, count_2 = c )

3.  In 2nd traversal of array, we will now over write the first ‘a’ indices / positions in array with ’0’,
the next ‘b’ with ‘1’ and the remaining ‘c’ with ‘2’.

Program :
---------
public class SortArray012BetterApproach {
    public static void main(String[] args) {
        int n = 6;
        int[] arr = new int[] {0, 2, 1, 2, 0, 1};
        sortArray(arr);
        System.out.println("After sorting:");
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    static void sortArray(int[] nums) {
        int num0 = 0;
        int num1 = 0;
        int num2 = 0;

        for(int i=0; i<nums.length; i++) {
            if(nums[i] == 0) {
                num0++;
            }
            else if(nums[i] == 1) {
                num1++;
            }
            else {
                num2++;
            }
        }


        for(int i=0; i<num0; i++) {
            nums[i] = 0;
        }

        for(int i=num0; i<num0+num1; i++) {
            nums[i] = 1;
        }

        for(int i=num0+num1; i<num0+num1+num2; i++) {
            nums[i] = 2;
        }
    }
}


Complexity Analysis
Time Complexity: O(N) + O(N), where N = size of the array. First O(N) for counting the number of 0’s, 1’s, 2’s,
and second O(N) for placing them correctly in the original array.

Space Complexity: O(1) as we are not using any extra space.

Optimal Approach :
------------------

Algorithm / Intuition
This problem is a variation of the popular Dutch National flag algorithm.

This algorithm contains 3 pointers i.e. low, mid, and high, and 3 main rules.  The rules are the following:

*   arr[0….low-1] contains 0. [Extreme left part]
*   arr[low….mid-1] contains 1.
*   arr[high+1….n-1] contains 2. [Extreme right part], n = size of the array

The middle part i.e. arr[mid….high] is the unsorted segment. So, hypothetically the array with different
markers will look like the following:

In our case, we can assume that the entire given array is unsorted and so we will place the pointers accordingly.
For example, if the given array is: [2,0,2,1,1,0], the array with the 3 pointers will look like the following:


Here, as the entire array is unsorted, we have placed the mid pointer in the first index and the high pointer in
the last index. The low is also pointing to the first index as we have no other index before 0. Here, we are mostly
interested in placing the ‘mid’ pointer and the ‘high’ pointer as they represent the unsorted part in the hypothetical array.

Now, let’s understand how the pointers will work to make the array sorted.

Approach:

Note: Here in this tutorial we will work based on the value of the mid pointer.

The steps will be the following:

1.  First, we will run a loop that will continue until mid <= high.
2.  There can be three different values of mid pointer i.e. arr[mid]
    2.1 If arr[mid] == 0, we will swap arr[low] and arr[mid] and will increment both low and mid.
    Now the subarray from index 0 to (low-1) only contains 0.
    2.2 If arr[mid] == 1, we will just increment the mid pointer and then the index (mid-1) will
    point to 1 as it should according to the rules.
    2.3 If arr[mid] == 2, we will swap arr[mid] and arr[high] and will decrement high. Now the
    subarray from index high+1 to (n-1) only contains 2.
    In this step, we will do nothing to the mid-pointer as even after swapping, the subarray from mid
    to high(after decrementing high) might be unsorted. So, we will check the value of mid again in the next iteration.
3.  Finally, our array should be sorted.

Program :
---------

/**
 * Dutch National flag algorithm.
 * */
public class SortArray012OptimalApproach {
    public static void main(String[] args) {
        int n = 6;
        int[] arr = new int[] {0, 2, 1, 2, 0, 1};
        sortArray(arr);
        System.out.println("After sorting:");
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void sortArray(int[] nums) {
        int low = 0;
        int mid = 0;
        int high = nums.length-1;

        while(mid <= high) {
            if(nums[mid] == 0) {
                int temp = nums[low];
                nums[low] = nums[mid];
                nums[mid] = temp;

                low++;
                mid++;
            }
            else if(nums[mid] == 1) {
                mid++;
            }
            else {
                int temp = nums[mid];
                nums[mid] = nums[high];
                nums[high] = temp;

                high--;
            }
        }
    }
}

Output :
After sorting:
0 0 1 1 2 2

Complexity Analysis
Time Complexity: O(N), where N = size of the given array.
Reason: We are using a single loop that can run at most N times.

Space Complexity: O(1) as we are not using any extra space.

---------------------------------------XXX-----------------------------------------------

Que 5 : Stock Buy And Sell
Level : Medium
Link : https://takeuforward.org/data-structure/stock-buy-and-sell/

Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Input: nums = [2,0,1]
Output: [0,1,2]

Input: nums = [0]
Output: [0]


Brute Force Approach
--------------------

Algorithm / Intuition
Intuition: We can simply use 2 loops and track every transaction and maintain a variable maxPro
to contain the max value among all transactions.

Approach:
*   Use a for loop of ‘i’ from 0 to n.
*   Use another for loop of j from ‘i+1’ to n.
*   If arr[j] > arr[i] , take the difference and compare  and store it in the maxPro variable.
*   Return maxPro.

Program :
---------

public class StockBuyAndSellBruteForce {
    public static void main(String[] args) {
        int arr[] = {7,1,5,3,6,4};
        int maxPro = maxProfit(arr);
        System.out.println("Max profit is: " + maxPro);
    }

    public static int maxProfit(int[] prices) {
        int maxProfit = Integer.MAX_VALUE;
        int size = prices.length;

        for(int i=0; i<size; i++) {
            for(int j=i+1; j<size; j++) {
                if(prices[j] > prices[i]) {
                    maxProfit = Math.max(prices[j] - prices[i], maxProfit);
                }
            }
        }

        return maxProfit;
    }
}

Output :
--------
Max profit is: 5

Complexity Analysis :
---------------------
Time complexity: O(n^2)
Space Complexity: O(1)


Optimal Approach
----------------

Algorithm / Intuition
Intuition: We will linearly travel the array. We can maintain a minimum from the start of the array
and compare it with every element of the array, if it is greater than the minimum then take the
difference and maintain it in max, otherwise update the minimum.

Approach:
---------

*   Create a variable maxPro and store 0 initially.
*   Create a variable minPrice and store some larger value(ex: MAX_VALUE) value initially.
*   Run a for loop from 0 to n.
*   Update the minPrice if it is greater than the current element of the array
*   Take the difference of the minPrice with the current element of the array and compare and maintain it in maxPro.
*   Return the maxPro.

Program:
-------

public class StockBuyAndSellOptimalSolution {
    public static void main(String[] args) {
        int arr[] = {7,1,5,3,6,4};
        int maxPro = maxProfit(arr);
        System.out.println("Max profit is: " + maxPro);
    }

    public static int maxProfit(int[] prices) {
        int minValue = Integer.MAX_VALUE;
        int maxValue = 0;
        int size = prices.length;

        for(int i=0; i<size; i++) {
            minValue = Math.min(prices[i], minValue);
            maxValue = Math.max(prices[i]-minValue, maxValue);
        }

        return maxValue;
    }
}

Output :
Max profit is: 5

Complexity Analysis
Time complexity: O(n)

Space Complexity: O(1)

---------------------------------------XXX-----------------------------------------------

Que 6 : Rotate Image by 90 degree
Level : Medium
Link : https://takeuforward.org/data-structure/rotate-image-by-90-degree/

Example 1:

Input: [[1,2,3],[4,5,6],[7,8,9]]

Output: [[7,4,1],[8,5,2],[9,6,3]]

Explanation: Rotate the matrix simply by 90 degree clockwise and return the matrix.

Example 2:

Input: [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]

Output:[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

Explanation: Rotate the matrix simply by 90 degree clockwise and return the matrix

Brute Force Approach
--------------------

Algorithm / Intuition
Approach: Take another dummy matrix of n*n, and then take the first row of the matrix and put it in
the last column of the dummy matrix, take the second row of the matrix, and put it in the second last
column of the matrix and so.

Program :
--------

public class RotateMatrixBruteForce {
    public static void main(String[] args) {
        int arr[][] =  {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int rotated[][] = rotate(arr);
        System.out.println("Rotated Image");
        for (int i = 0; i < rotated.length; i++) {
            for (int j = 0; j < rotated.length; j++) {
                System.out.print(rotated[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static int[][] rotate(int[][] matrix) {
        int n = matrix.length;
        int rotateMatrix[][] = new int[n][n];

        for(int i=0; i<n; i++) {
            for(int j=0; j<n; j++) {
                rotateMatrix[j][n-i-1] = matrix[i][j];
            }
        }

        return rotateMatrix;
    }
}

Output :
Rotated Image
7 4 1
8 5 2
9 6 3

Complexity Analysis
-------------------
Time Complexity: O(N*N) to linearly iterate and put it into some other matrix.
Space Complexity: O(N*N) to copy it into some other matrix.


Optimal Approach
----------------

Algorithm / Intuition
Intuition: By observation, we see that the first column of the original matrix is the reverse of
the first row of the rotated matrix, so that’s why we transpose the matrix and then reverse each row,
and since we are making changes in the matrix itself space complexity gets reduced to O(1).

Approach:
---------
Step 1: Transpose the matrix. (transposing means changing columns to rows and rows to columns)
Step 2: Reverse each row of the matrix.

program:
--------

public class RotateMatrixOptimalApproach {
    public static void main(String[] args) {
        int arr[][] =  {{11, 12, 13, 14}, {15, 16, 17, 18}, {19, 20, 21, 22}, {23, 24, 25, 26}};
        rotate(arr);
        System.out.println("Rotated Image");
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
    }

    static void rotate(int[][] matrix) {
        // find out the transpose of matrix
        int row = matrix.length;
        int col = matrix[0].length;
        int size = matrix.length;

        for(int i=0; i<row; i++) {
            for(int j=i; j<col; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // reverse the transpose matrix
        for(int i=0; i<size; i++) {
            for(int j=0; j<size/2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][size-j-1];
                matrix[i][size-j-1] = temp;
            }
        }
    }
}

Output :
Rotated Image
23 19 15 11
24 20 16 12
25 21 17 13
26 22 18 14

Complexity Analysis :
Time Complexity: O(N*N) + O(N*N).One O(N*N) is for transposing the matrix and the other is for
reversing the matrix.
Space Complexity: O(1).

---------------------------------------XXX-----------------------------------------------

Que 7 : Find the duplicate in an array of N+1 integers
Problem Statement: Given an array of N + 1 size, where each element is between 1 and N.
Assuming there is only one duplicate number, your task is to find the duplicate number.
Level : Medium
Link : https://takeuforward.org/data-structure/find-the-duplicate-in-an-array-of-n1-integers/

Example 1:

Input: arr=[1,3,4,2,2]

Output: 2

Explanation: Since 2 is the duplicate number the answer will be 2.

Example 2:

Input: [3,1,3,4,2]

Output:3

Explanation: Since 3 is the duplicate number the answer will be 3.

BruteForce Approach :
---------------------

Solution 1:Using sorting
Approach: Sort the array. After that, if there is any duplicate number they will be adjacent.
So we simply have to check if arr[i]==arr[i+1] and if it is true,arr[i] is the duplicate number.

Program :
public class FindDuplicateInArrayBruteForce {
    public static void main(String[] args) {
        int arr[] = {1,3,4,2,2};
        System.out.println("The duplicate element is " + findDuplicate(arr));
    }

    private static int findDuplicate(int arr[]) {
        int n = arr.length;

        Arrays.sort(arr);

        for(int i=0; i<n; i++) {
            if(arr[i] == arr[i+1]) {
                return arr[i];
            }
        }

        return 0;
    }
}

Output :
The duplicate element is 2

Time Complexity:O(Nlogn + N)
Reason: NlogN for sorting the array and O(N) for traversing through the array and checking
if adjacent elements are equal or not. But this will distort the array.

Space Complexity:O(1)


Better Approach :
-----------------

Solution 2:Using frequency array

Approach: Take a frequency array of size N+1 and initialize it to 0. Now traverse through the array and if the frequency of the
element is 0 increase it by 1, else if the frequency is not 0 then that element is the required answer.

Program :

public class FindDuplicateInArrayBetterApproach {
    public static void main(String[] args) {
        int arr[] = {1,3,4,2,2};
        System.out.println("The duplicate element is " + findDuplicate(arr));
    }

    private static int findDuplicate(int arr[]) {
        int size = arr.length;
        int[] freqArray = new int[size+1];

        for (int i = 0; i < size; i++) {
            if(freqArray[arr[i]] == 0) {
                freqArray[arr[i]] += 1;
            }
            else {
                return arr[i];
            }
        }
        return 0;
    }
}

Output :
The duplicate element is 2

Time Complexity: O(N), as we are traversing through the array only once.
Space Complexity: O(N), as we are using extra space for frequency array.


Optimal Approach :
Solution 3: Linked List cycle method

Approach: Let’s take an example and dry run on it to understand.

Index  : 0  1  2  3  4  5  6  7  8  9
-------------------------------------
Number : 2  5  9  6  9  3  8  9  7  1

Initially, we have 2, then we got to the second index, we have 9, then we go to the 9th index,
we have 1, then we go to the 1st index, we again have 5, then we go to the 5th index,
we have 3, then we go to the 3rd index, we get 6, then we go to the 6th index, we get 8,
then we go to the 8th index, we get 7, then we go to the 7th index and we get 9 and here
cycle is formed.

Now initially, the slow and fast pointer is at the start, the slow pointer moves by one step, and the
fast pointer moves by 2 steps.

// Images On Website

The slow and fast pointers meet at 7. Now take the fast pointer and place it at the first element i.e 2
and move the fast and slow pointer both by 1 step. The point where they collide will be the duplicate number.

// Images On Website

So 9 is the duplicate number.

Intuition: Since there is a duplicate number, we can always say that cycle will be formed.

The slow pointer moves by one step and the fast pointer moves by 2 steps and there exists a cycle so the
first collision is bound to happen.

// Image on Website

Let’s assume the distance between the first element and the first collision is a. So slow pointer has
traveled a distance while fast(since moving 2 steps at a time) has traveled 2a distance. For slow and a fast
pointer to collide 2a-a=a should be multiple of the length of cycle, Now we place a fast pointer to start.
Assume the distance between the start and duplicate to be x. So now the distance between slow and
duplicate shows also be x, as seen from the diagram, and so now fast and slow pointer both should move
by one step.


Program :
---------

public class FindDuplicateOptimalApproach {
    public static void main(String[] args) {
        int arr[] = {2,5,9,6,9,3,8,9,7,1};
        System.out.println("The duplicate element is " + findDuplicate(arr));
    }

    public static int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        fast = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}

Output :
The duplicate element is 9

Time complexity: O(N). Since we traversed through the array only once.
Space complexity: O(1).

---------------------------------------XXX-----------------------------------------------

Que 8 : Find the Majority Element that occurs more than N/2 times
Problem Statement: Given an array of N integers, write a program to return an element that
occurs more than N/2 times in the given array. You may consider that such an element always exists in the array.
Level : Medium
Link : https://takeuforward.org/data-structure/find-the-majority-element-that-occurs-more-than-n-2-times/

Example 1:
Input Format: N = 3, nums[] = {3,2,3}
Result: 3
Explanation: When we just count the occurrences of each number and compare with half of the size of the array, you will get 3 for the above solution.

Example 2:
Input Format:  N = 7, nums[] = {2,2,1,1,1,2,2}
Result: 2
Explanation: After counting the number of times each element appears and comparing it with half of array size, we get 2 as result.

Example 3:
Input Format:  N = 10, nums[] = {4,4,2,4,3,4,4,3,2,4}
Result: 4

Brute Force Approach :
----------------------

The steps are as follows:
1. We will run a loop that will select the elements of the array one by one.
2. Now, for each element, we will run another loop and count its occurrence in the given array.
3. If any element occurs more than the floor of (N/2), we will simply return it.

Program :
public class MajorityElementBruteForceApproach {
    public static void main(String[] args) {
        int[] arr = {2, 2, 1, 1, 1, 2, 2};
        int ans = majorityElement(arr);
        System.out.println("The majority element is: " + ans);
    }

    public static int majorityElement(int[] arr) {
        int size = arr.length;

        for(int i=0; i<size; i++) {
            int count = 0;
            for(int j=0; j<size; j++) {
                if(arr[i] == arr[j]) {
                    count++;
                }
            }

            if(count > size/2) {
                return arr[i];
            }
        }

        return -1;
    }
}

Output :
The majority element is: 2

Complexity Analysis
-------------------

Time Complexity: O(N2), where N = size of the given array. Reason: For every element of the
array the inner loop runs for N times. And there are N elements in the array. So, the total
time complexity is O(N2). Space Complexity: O(1) as we use no extra space.

Better Approach :
-----------------
Solution 2 (Better):
Intuition:
Use a better data structure to reduce the number of look-up operations and hence the time
complexity. Moreover, we have been calculating the count of the same element again and again –
so we have to reduce that also.

Approach:
1. Use a hashmap and store as (key, value) pairs. (Can also use frequency array based on the
size of nums)
2. Here the key will be the element of the array and the value will be the number of times it
occurs.
3. Traverse the array and update the value of the key. Simultaneously check if the value is
greater than the floor of N/2.
    1. If yes, return the key
    2. Else iterate forward.

Program :
public class MajorityElementBetterApproach {
    public static void main(String[] args) {
        int[] arr = {2, 2, 1, 1, 1, 2, 2};
        int ans = majorityElement(arr);
        System.out.println("The majority element is: " + ans);
    }

    public static int majorityElement(int[] arr) {
        int size = arr.length;
        HashMap<Integer, Integer> map = new HashMap<>();

        for(int i=0; i<size; i++) {
            int value = map.getOrDefault(arr[i], 0);
            map.put(arr[i], value+1);
        }

        for(Map.Entry<Integer, Integer> pair : map.entrySet()) {
            if(pair.getValue() > size/2) {
                return pair.getKey();
            }
        }

        return -1;
    }
}

Output :
The majority element is: 2

Complexity Analysis
Time Complexity: O(N*logN) + O(N), where N = size of the given array.
Reason: We are using a map data structure. Insertion in the map takes logN time. And we are
doing it for N elements. So, it results in the first term O(N*logN). The second O(N) is for
checking which element occurs more than floor(N/2) times. If we use unordered_map instead,
the first term will be O(N) for the best and average case and for the worst case,
it will be O(N2).

Space Complexity: O(N) as we are using a map data structure.


Optimal Approach :
------------------

Optimal Approach: Moore’s Voting Algorithm:
Intuition:
If the array contains a majority element, its occurrence must be greater than the floor(N/2).
Now, we can say that the count of minority elements and majority elements is equal up to a
certain point in the array. So when we traverse through the array we try to keep track of the
count of elements and the element itself for which we are tracking the count.

After traversing the whole array, we will check the element stored in the variable. If the
question states that the array must contain a majority element, the stored element will be
that one but if the question does not state so, then we need to check if the stored element
is the majority element or not. If not, then the array does not contain any majority element.

Approach:
1. Initialize 2 variables:
    Count –  for tracking the count of element
    Element – for which element we are counting
2. Traverse through the given array.
    1. If Count is 0 then store the current element of the array as Element.
    2. If the current element and Element are the same increase the Count by 1.
    3. If they are different decrease the Count by 1.
3. The integer present in Element should be the result we are expecting

Dry Run:

The yellow-colored element represents the current element.

// Content Of Images

Basically, we are trying to keep track of the occurrences of the majority element and minority
elements dynamically. That is why, in iteration 4, the count becomes 0 as the occurrence of
Element and the occurrence of the other elements are the same. So, they canceled each other.
This is how the process works. The element with the most occurrence will remain and the rest
will cancel themselves.

Here, we can see that 2 is the majority element. But if in this array, the last two elements
were 3, then the Element variable would have stored 3 instead of 2. For that, we need to
check if the Element is the majority element by traversing the array once more. But if the
question guarantees that the given array contains a majority element, then we can bet the
Element will store the majority one.

Note: For a better understanding of intuition, please watch the video at the bottom of the page.

Program :
public class MajorityElementOptimalApproach {
    public static void main(String[] args) {
        int[] arr = {2, 2, 1, 1, 1, 2, 2};
        int ans = majorityElement(arr);
        System.out.println("The majority element is: " + ans);
    }

    /**
     * Moore’s Voting Algorithm
     * */
    public static int majorityElement(int[] arr) {
        int count = 0;
        int element = 0;
        int size = arr.length;

        //applying the algorithm
        for(int i=0; i<size; i++) {
            if(count == 0) {
                count++;
                element = arr[i];
            }
            else if(element == arr[i]) {
                count++;
            }
            else {
                count--;
            }
        }

        // checking if the stored element
        // is the majority element
        int countOfElement = 0;
        for(int i=0; i<size; i++) {
            if(element == arr[i]) {
                countOfElement++;
            }
        }

        if(countOfElement > size/2) {
            return element;
        }
        else {
            return -1;
        }
    }
}


Output :
The majority element is: 2

Complexity Analysis
-------------------

Time Complexity: O(N) + O(N), where N = size of the given array.
Reason: The first O(N) is to calculate the count and find the expected majority element.
The second one is to check if the expected element is the majority one or not.

Note: If the question states that the array must contain a majority element, in that case,
we do not need the second check. Then the time complexity will boil down to O(N).

Space Complexity: O(1) as we are not using any extra space.

---------------------------------------XXX-----------------------------------------------

Que 9 : Two Sum : Check if a pair with given sum exists in Array
Problem Statement: Given an array of integers arr[] and an integer target.
Level : Medium
Link : https://takeuforward.org/data-structure/two-sum-check-if-a-pair-with-given-sum-exists-in-array/

Note: You are not allowed to use the same element twice. Example: If the target is equal to 6 and num[1] = 3,
then nums[1] + nums[1] = target is not a solution.

Examples:

Example 1:
Input Format: N = 5, arr[] = {2,6,5,8,11}, target = 14
Result: YES (for 1st variant)
       [1, 3] (for 2nd variant)
Explanation: arr[1] + arr[3] = 14. So, the answer is “YES” for the first variant and [1, 3] for 2nd variant.

Example 2:
Input Format: N = 5, arr[] = {2,6,5,8,11}, target = 15
Result: NO (for 1st variant)
	[-1, -1] (for 2nd variant)
Explanation: There exist no such two numbers whose sum is equal to the target.

Brute Force Approach :
----------------------
Intuition: For each element of the given array, we will try to search for another element such
that its sum is equal to the target. If such two numbers exist, we will return the indices or
“YES” accordingly.

Approach:

*   First, we will use a loop(say i) to select the indices of the array one by one.
*   For every index i, we will traverse through the remaining array using another loop(say j)
    to find the other number such that the sum is equal to the target
    (i.e. arr[i] + arr[j] = target).

Observation: In every iteration, if the inner loop starts from index 0, we will be checking the
same pair of numbers multiple times. For example, in iteration 1, for i = 0, we will check for
the pair arr[0] and arr[1]. Again in iteration 2, for i = 1, we will check arr[1] and arr[0].
So, to eliminate these same pairs, we will start the inner loop from i+1.

Dry Run: Given array, nums = [2,1,3,4], target = 4

Using the naive approach, we first select one number and then find the second one.

For index 0, element= 2,
Then, we iterate through indices 1 to 3 to check if target – x, i.e. 4 – 2 = 2 exists.
2 does not exist from index 1 to 3, we move to the next index.

For index 1, element=1,
Then, we iterate through indices 2 to 3 to find if target – x, i.e. 4 – 1 = 3 exists.
3 exists at index 2, so we store the indices 1 and 2, break the loop, and return the indices.

Program :

public class TwoSumBruteForce {
    public static void main(String args[]) {
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        int[] ans = twoSum(arr, target);
        System.out.println("This is the answer for variant 2: [" + ans[0] + ", " + ans[1] + "]");
    }

    public static int[] twoSum(int[] nums, int target) {
        int[] answer = new int[2];
        int size = nums.length;

        for(int i=0; i<size; i++) {
            for(int j=i+1; j<size; j++) {
                if(nums[i] + nums[j] == target) {
                    answer[0] = i;
                    answer[1] = j;

                    return answer;
                }
            }
        }

        return answer;
    }
}

Output :
This is the answer for variant 2: [1, 3]

Time Complexity: O(N2), where N = size of the array.
Reason: There are two loops(i.e. nested) each running for approximately N times.
Space Complexity: O(1) as we are not using any extra space.


Better Approach(using Hashing):
-------------------------------

Intuition: Basically, in the previous approach we selected one element and then searched for the other one
using a loop. Here instead of using a loop, we will use the HashMap to check if the other element i.e.
target-(selected element) exists. Thus we can trim down the time complexity of the problem.

And for the second variant, we will store the element along will its index in the HashMap.
Thus we can easily retrieve the index of the other element i.e. target-(selected element) without iterating
the array.

Approach:

The steps are as follows:

1.  We will select the element of the array one by one using a loop(say i).
2.  Then we will check if the other required element(i.e. target-arr[i]) exists in the hashMap.
        1. If that element exists, then we will return “YES” for the first variant or we will return the current
           index i.e. i, and the index of the element found using map i.e. mp[target-arr[i]].
        2. If that element does not exist, then we will just store the current element in the hashMap along with
           its index. Because in the future, the current element might be a part of our answer.
3.  Finally, if we are out of the loop, that means there is no such pair whose sum is equal to the target.
    In this case, we will return either “NO” or {-1, -1} as per the variant of the question.

Dry Run: Given array, nums = [2,3,1,4], target = 4

Note: Here x denotes the currently selected element.

For index 0, x = 2, and currently map is empty.
We try to find if target – x = 4 – 2 = 2 is present in the map or not.
For now, 2 does not exist on the map.
And we store the index of element 2. i.e., mp[2] = 0,

For index 1, x = 3
We try to find if target – x = 4  – 3 = 1 is present in the map or not.
For now, 1 does not exist on the map.
And we store the index of element 3. i.e., mp[3] = 1,

For index 2, x = 1
We try to find if target – i = 4  – 1 = 3 is present in the map or not. 3 exists in the map,
so we store index 2 and the value stored for key 3 in the map and break the loop.
And return [1,2].

Program :

public class TwoSumBetterApproach {
    public static void main(String args[]) {
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        int[] ans = twoSum(arr, target);
        System.out.println("This is the answer for variant 2: [" + ans[0] + ", " + ans[1] + "]");
    }

    public static int[] twoSum(int[] arr, int target) {
        int[] ans = new int[2];
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        int size = arr.length;

        for(int i=0; i<size; i++) {
            int moreNeeded = target - arr[i];

            if(hashMap.containsKey(moreNeeded)) {
                ans[0] = hashMap.get(moreNeeded);
                ans[1] = i;

                return ans;
            }

            hashMap.put(arr[i], i);
        }

        return ans;
    }
}

Output :
This is the answer for variant 2: [1, 3]

Time Complexity: O(N), where N = size of the array.
Reason: The loop runs N times in the worst case and searching in a hashmap takes O(1) generally.
So the time complexity is O(N).

Note: In the worst case(which rarely happens), the unordered_map takes O(N) to find an element.
In that case, the time complexity will be O(N2). If we use map instead of unordered_map,
the time complexity will be O(N* logN) as the map data structure takes logN time to find an element.

Space Complexity: O(N) as we use the map data structure.

Note: We have optimized this problem enough. But if in the interview, we are not allowed to use the
map data structure, then we should move on to the following approach i.e. two pointer approach.
This approach will have the same time complexity as the better approach.

Optimized Approach(using two-pointer):
--------------------------------------

Intuition: In this approach, we will first sort the array and will try to choose the numbers in a greedy way.

We will keep a left pointer at the first index and a right pointer at the last index. Now until left < right,
we will check the sum of arr[left] and arr[right]. Now if the sum < target, we need bigger numbers and so we
will increment the left pointer. But if sum > target, we need to consider lesser numbers and so we will
decrement the right pointer.

If sum == target we will return either “YES” or the indices as per the question.
But if the left crosses the right pointer, we will return “NO” or {-1, -1}.

Approach:

The steps are the following:

1.  We will sort the given array first.
2.  Now, we will take two pointers i.e. left, which points to the first index, and right, which points to
    the last index.
3.  Now using a loop we will check the sum of arr[left] and arr[right] until left < right.
        1. If arr[left] + arr[right] > sum, we will decrement the right pointer.
        2. If arr[left] + arr[right] < sum, we will increment the left pointer.
        3. If arr[left] + arr[right] == sum, we will return the result.
4.  Finally, if no results are found we will return “No” or {-1, -1}.

Dry Run: Given array, nums = [2,1,3,4], target = 4

First, we sort the array. So nums after sorting are [1,2,3,4]

We take two-pointers, left and right. The left points to index 0 and the right points to index 3.

Now we check if nums[left] + nums[right] == target. In this case, they don’t sum up, and nums[left] +
nums[right] > target so that we will reduce right by 1.

Now, left = 0, right=2

Here, nums[left] + nums[right] == 1 + 3 == 4, which is the required target, so we will return the result.

Program :
public class TwoSumOptimalApproach {
    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        String ans = twoSum(n, arr, target);
        System.out.println("This is the answer for variant 1: " + ans);
    }

    public static String twoSum(int n, int[] arr, int target) {
        Arrays.sort(arr);
        int left = 0;
        int right = n-1;

        while(left < right) {
            int sum = arr[left] + arr[right];

            if(sum == target) {
                return "YES";
            }
            else if(sum > target) {
                right--;
            }
            else {
                left++;
            }
        }

        return "NO";
    }
}

Output :
This is the answer for variant 1: YES

Note: For variant 2, we can store the elements of the array along with its index in a new array. Then the
rest of the code will be similar. And while returning, we need to return the stored indices instead of
returning “YES”. But for this variant, the recommended approach is approach 2 i.e. hashing approach.

Time Complexity: O(N) + O(N*logN), where N = size of the array.
Reason: The loop will run at most N times. And sorting the array will take N*logN time complexity.

Space Complexity: O(1) as we are not using any extra space.

Note: Here we are distorting the given array. So, if we need to consider this change, the space
complexity will be O(N).

---------------------------------------XXX-----------------------------------------------

Que 10 : Longest Consecutive Sequence in an Array
Problem Statement: You are given an array of ‘N’ integers. You need to find the length of the longest sequence which contains
the consecutive elements.
Level : Medium
Link : https://takeuforward.org/data-structure/longest-consecutive-sequence-in-an-array/

Example 1:
Input: [100, 200, 1, 3, 2, 4]
Output: 4
Explanation: The longest consecutive subsequence is 1, 2, 3, and 4.

Input: [3, 8, 5, 7, 6]
Output: 4
Explanation: The longest consecutive subsequence is 5, 6, 7, and 8.

Brute-force Approach:
---------------------

A straightforward but basic solution is to examine consecutive sequences for each element in the
given array. For every element x, we will try to find the consecutive elements, x+1, x+2, x+3, and so
on using the linear search algorithm. Thus, we will check the length of the longest consecutive
subsequence we can build for every element x. Among all the lengths we will consider the maximum one.

Algorithm:
1.  To begin, we will utilize a loop to iterate through each element one by one.
2.  Next, for every element x, we will try to find the consecutive elements like x+1, x+2, x+3, and so
    on using the linear search algorithm in the given array.
        1. Within a loop, our objective is to locate the next consecutive element x+1.
            1. If this element is found, we increment x by 1 and continue the search for x+2.
            2. Furthermore, we increment the length of the current sequence (cnt) by 1.

This process repeats until step 2.2 occurs.

3.  If a specific consecutive element, for example, x+i, is not found, we will halt the search for
    subsequent consecutive elements such as x+i+1, x+i+2, and so on. Instead, we will take into
    account the length of the current sequence (cnt).
4.  Among all the lengths we get for all the given array elements, the maximum one will be the answer.

Program :
public class LongestConsecutiveSequenceBruteForce {
    public static boolean linearSearch(int[] arr, int num) {
        int size = arr.length; //size of array
        for (int i = 0; i < size; i++) {
            if (arr[i] == num)
                return true;
        }
        return false;
    }
    public static int longestSuccessiveElements(int[] arr) {
        int size = arr.length; //size of array
        int longest = 1;

        //pick a element and search for its
        //consecutive numbers:
        for (int i = 0; i < size; i++) {
            int x = arr[i];
            int cnt = 1;
            //search for consecutive numbers
            //using linear search:
            while (linearSearch(arr, x + 1) == true) {
                x += 1;
                cnt += 1;
            }

            longest = Math.max(longest, cnt);
        }
        return longest;
    }

    public static void main(String[] args) {
        int[] arr = {100, 200, 1, 2, 3, 4};
        int ans = longestSuccessiveElements(arr);
        System.out.println("The longest consecutive sequence is " + ans);
    }
}

Output :
The longest consecutive sequence is 4

Complexity Analysis
Time Complexity: O(N2), N = size of the given array.
Reason: We are using nested loops each running for approximately N times.

Space Complexity: O(1), as we are not using any extra space to solve this problem.


Better Approach :
-----------------

Algorithm / Intuition
Better Approach(Using sorting):
We can simply sort the array and run a for loop to find the longest consecutive sequence.

Algorithm:
* We will consider 3 variables,
    * ‘lastSmaller’ →(to store the last included element of the current sequence),
    * ‘cnt’ → (to store the length of the current sequence),
    * ‘longest’ → (to store the maximum length).
* Initialize ‘lastSmaller’ with ‘INT_MIN’, ‘cnt’ with 0, and ‘longest’ with 1(as the minimum
  length of the sequence is 1).

The steps are as follows:

1.  First, we will sort the entire array.
2.  To begin, we will utilize a loop(say i) to iterate through each element one by one.
3.  For every element, we will check if this can be a part of the current sequence like the following:
        1. If arr[i]-1 == lastSmaller: The last element in our sequence is labeled as ‘lastSmaller’ and
        the current element ‘arr[i]’ is exactly ‘lastSmaller’+1. It indicates that ‘arr[i]’ is the next
        consecutive element. To incorporate it into the sequence, we update ‘lastSmaller’ with the
        value of ‘arr[i]’ and increment the length of the current sequence, denoted as ‘cnt’, by 1.
        2. If arr[i] == lastSmaller: If the current element, arr[i], matches the last element of the
        sequence (represented by ‘lastSmaller’), we can skip it since we have already included it before.
        3. Otherwise, if lastSmaller != arr[i]: On satisfying this condition, we can conclude that the
        current element, arr[i] > lastSmaller+1. It indicates that arr[i] cannot be a part of the
        current sequence. So, we will start a new sequence from arr[i] by updating ‘lastSmaller’
        with the value of arr[i]. And we will set the length of the current sequence(cnt) to 1.
4.  Every time, inside the loop, we will compare ‘cnt’ and ‘longest’ and update ‘longest’ with the maximum
    value. longest = max(longest, cnt)
5.  Finally, once the iteration is complete, we will have the answer stored in the variable ‘longest’.

Program :
public class LongestConsecutiveSequenceOptimal1 {
    public static int longestSuccessiveElements(int[] arr)
    {
        int size = arr.length;
        if (size == 0) return 0;

        //sort the array:
        Arrays.sort(arr);
        int lastSmaller = Integer.MIN_VALUE;
        int count = 0;
        int longest = 1;

        //find longest sequence:
        for (int i = 0; i < size; i++)
        {
            if (arr[i] - 1 == lastSmaller) {
                //arr[i] is the next element of the
                //current sequence.
                count += 1;
                lastSmaller = arr[i];
            } else if (arr[i] != lastSmaller) {
                count = 1;
                lastSmaller = arr[i];
            }
            longest = Math.max(longest, count);
        }
        return longest;
    }

    public static void main(String[] args) {
        int[] arr = {100, 200, 1, 2, 3, 4};
        int ans = longestSuccessiveElements(arr);
        System.out.println("The longest consecutive sequence is " + ans);
    }
}

Output :
The longest consecutive sequence is 4

Complexity Analysis :
---------------------
Time Complexity: O(NlogN) + O(N), N = size of the given array.
Reason: O(NlogN) for sorting the array. To find the longest sequence, we are using a loop that results in O(N).

Space Complexity: O(1), as we are not using any extra space to solve this problem.

Optimal Approach :
------------------
Optimal Approach(Using Set data structure):
    We will adopt a similar approach to the brute-force method but with optimizations in the search
    process. Instead of searching sequences for every array element as in the brute-force approach,
    we will focus solely on finding sequences only for those numbers that can be the starting numbers
    of the sequences. This targeted approach narrows down our search and improves efficiency.

    We will do this with the help of the Set data structure.

How to identify if a number can be the starting number for a sequence:

* First, we will put all the array elements into the set data structure.
* If a number, num, is a starting number, ideally, num-1 should not exist. So, for every element, x,
  in the set, we will check if x-1 exists inside the set. :
    * If x-1 exists: This means x cannot be a starting number and we will move on to the next element
      in the set.
    * If x-1 does not exist: This means x is a starting number of a sequence. So, for number, x,
      we will start finding the consecutive elements.

How to search for consecutive elements for a number, x:

  * Instead of using linear search, we will use the set data structure itself to search for the
    elements x+1, x+2, x+3, and so on.
Thus, using this method we can narrow down the search and optimize the approach.

Algorithm:
We will declare 2 variables,

* ‘cnt’ → (to store the length of the current sequence),
* ‘longest’ → (to store the maximum length).

    1. First, we will put all the array elements into the set data structure.
    2. For every element, x, that can be a starting number(i.e. x-1 does not exist in the set) we will do
       the following:
            1. We will set the length of the current sequence(cnt) to 1.
            2. Then, again using the set, we will search for the consecutive elements such as x+1, x+2,
               and so on, and find the maximum possible length of the current sequence. This length will be
               stored in the variable ‘cnt’.
            3. After that, we will compare ‘cnt’ and ‘longest’ and update the variable ‘longest’ with the
               maximum value (i.e. longest = max(longest, cnt)).
    3. Finally, we will have the answer i.e. ‘longest’.

Program :
public class LongestConsecutiveSequenceOptimal2 {
    public static int longestSuccessiveElements(int[] a)
    {
        int size = a.length;
        if (size == 0) {
            return 0;
        }

        int longest = 1;
        Set<Integer> set = new HashSet<>();

        // put all the array elements into set
        for (int i = 0; i < size; i++) {
            set.add(a[i]);
        }

        // Find the longest sequence
        for (int it : set) {
            // if 'it' is a starting number
            if (!set.contains(it - 1)) {
                // find consecutive numbers
                int count = 1;
                int x = it;
                while (set.contains(x + 1)) {
                    x = x + 1;
                    count = count + 1;
                }
                longest = Math.max(longest, count);
            }
        }
        return longest;
    }

    public static void main(String[] args) {
        int[] a = {100, 200, 1, 2, 3, 4};
        int ans = longestSuccessiveElements(a);
        System.out.println("The longest consecutive sequence is " + ans);
    }
}

Output :
The longest consecutive sequence is 4

Complexity Analysis :
---------------------

Time Complexity: O(N) + O(2*N) ~ O(3*N), where N = size of the array.
Reason: O(N) for putting all the elements into the set data structure. After that for every
starting element, we are finding the consecutive elements. Though we are using nested loops,
the set will be traversed at most twice in the worst case. So, the time complexity is
O(2*N) instead of O(N2).

Space Complexity: O(N), as we are using the set data structure to solve this problem.

Note: The time complexity is computed under the assumption that we are using unordered_set and it is taking O(1) for the set operations.

    * If we consider the worst case the set operations will take O(N) in that case and the
      total time complexity will be approximately O(N2).
    * And if we use the set instead of unordered_set, the time complexity for the set
      operations will be O(logN) and the total time complexity will be O(NlogN).

---------------------------------------XXX-----------------------------------------------

Que 11 : Count inversions in an array
Problem Statement: Given an array of N integers, count the inversion of the array (using merge-sort).
What is an inversion of an array? Definition: for all i & j < size of array, if i < j then you have to find pair (A[i],A[j])
such that A[j] < A[i].
Level : Medium
Link : https://takeuforward.org/data-structure/count-inversions-in-an-array/

Example 1:
Input Format: N = 5, array[] = {1,2,3,4,5}
Result: 0
Explanation: we have a sorted array and the sorted array has 0 inversions as for i < j you will never find a pair such that
A[j] < A[i]. More clear example: 2 has index 1 and 5 has index 4 now 1 < 5 but 2 < 5 so this is not an inversion.

Example 2:
Input Format: N = 5, array[] = {5,4,3,2,1}
Result: 10
Explanation: we have a reverse sorted array and we will get the maximum inversions as for i < j we will always find a pair
such that A[j] < A[i]. Example: 5 has index 0 and 3 has index 2 now (5,3) pair is inversion as 0 < 2 and 5 > 3 which will
satisfy out conditions and for reverse sorted array we will get maximum inversions and that is (n)*(n-1) / 2.For above given
array there is 4 + 3 + 2 + 1 = 10 inversions.

Example 3:
Input Format: N = 5, array[] = {5,3,2,1,4}
Result: 7
Explanation: There are 7 pairs (5,1), (5,3), (5,2), (5,4),(3,2), (3,1), (2,1) and we have left 2 pairs (2,4) and (1,4) as
both are not satisfy our condition.

Brute Force Approach
--------------------

Algorithm / Intuition
---------------------
Solution:

Let’s understand the Question more deeply. We are required to give the total number of inversions and the inversions are:
For i & j < size of an array if i < j then you have to find pair (a[i], a[j]) such that a[i] > a[j].

For example, for the given array: [5,3,2,1,4], (5, 3) will be a valid pair as 5 > 3 and
index 0 < index 1. But (1, 4) cannot be valid pair.

Naive Approach (Brute force):

Approach:

The steps are as follows:

1.  First, we will run a loop(say i) from 0 to N-1 to select the first element in the pair.
2.  As index j should be greater than index i, inside loop i, we will run another loop i.e. j from i+1 to N-1.
3.  Inside this second loop, we will check if a[i] > a[j] i.e. if a[i] and a[j] can be a pair. If they satisfy the
    condition, we will increase the count by 1.
4.  Finally, we will return the count i.e. the number of such pairs.

Intuition: The naive approach is pretty straightforward. We will use nested loops to solve this problem. We know index i
must be smaller than index j. So, we will fix i at one index at a time through a loop, and with another loop, we will
check(the condition a[i] > a[j]) the elements from index i+1 to N-1  if they can form a pair with a[i]. This is the first
naive approach we can think of.

Note: For a better understanding of intuition, please watch the video at the bottom of the page.

Program :

public class InversionInArrayBruteForce {
    public static void main(String[] args) {
        long[] a = {5, 4, 3, 2, 1};
        int n = 5;
        long cnt = numberOfInversions(a, n);
        System.out.println("The number of inversions is: " + cnt);
    }

    public static long numberOfInversions(long arr[], int n) {
        int count = 0;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] > arr[j]) {
                    count++;
                }
            }
        }

        return count;
    }
}

Output :
The number of inversions is: 10

Complexity Analysis
-------------------
Time Complexity: O(N^2), where N = size of the given array.
Reason: We are using nested loops here and those two loops roughly run for N times.

Space Complexity: O(1) as we are not using any extra space to solve this problem.


Optimal Approach
----------------

Algorithm / Intuition
Observation:

Let’s build the intuition for this approach using a modified version of the given question.

Assume two sorted arrays are given i.e. a1[] = {2, 3, 5, 6} and a2[] = {2, 2, 4, 4, 8}. Now, we have to count the pairs
i.e. a1[i] and a2[j] such that a1[i] > a2[j].

In order to solve this, we will keep two pointers i and j, where i will point to the first index of a1[] and j will point
to the first index of a2[]. Now in each iteration, we will do the following:

*   If a1[i] <= a2[j]: These two elements cannot be a pair and so we will move the pointer i to the next position.
    This case is illustrated below:

// Image

*   Why we moved the i pointer: We know, that the given arrays are sorted. So, all the elements after the pointer j, should
    be greater than a2[j]. Now, as a1[i] is smaller or equal to a2[j], it is obvious that a1[i] will be smaller or equal to
    all the elements after a2[j]. We need a bigger value of a1[i] to make a pair and so we move the i pointer to the next
    position i.e. next bigger value.
*   If a1[i] > a2[j]: These two elements can be a pair and so we will update the count of pairs. Now, here, we should observe
    that as a1[i] is greater than a2[j], all the elements after a1[i] will also be greater than a2[j] and so, those elements
    will also make pair with a2[j]. So, the number of pairs added will be n1-i (where n1 = size of a1[ ]). Now, we will move
    the j pointer to the next position. This case is also illustrated below:

// Image

The above process will continue until at least one of the pointers reaches the end.

Until now, we have figured out how to count the number of pairs in one go if two sorted arrays are given. But in our actual
question, only a single unsorted array is given. So, how to break it into two sorted halves so that we can apply the above
observation?


We can think of the merge sort algorithm that works in a similar way we want. In the merge sort algorithm, at every step,
we divide the given array into two halves and then sort them, and while doing that we can actually count the number of pairs.

Basically, we will use the merge sort algorithm to use the observation in the correct way.

Approach:
The steps are basically the same as they are in the case of the merge sort algorithm. The change will be just a
one-line addition inside the merge() function. Inside the merge(), we need to add the number of pairs to the count when
a[left] > a[right].

The steps of the merge() function were the following:

1.  In the merge function, we will use a temp array to store the elements of the two sorted arrays after merging.
    Here, the range of the left array is low to mid and the range for the right half is mid+1 to high.
2.  Now we will take two pointers left and right, where left starts from low and right starts from mid+1.
3.  Using a while loop( while(left <= mid && right <= high)), we will select two elements, one from each half, and will
    consider the smallest one among the two. Then, we will insert the smallest element in the temp array.
4.  After that, the left-out elements in both halves will be copied as it is into the temp array.
5.  Now, we will just transfer the elements of the temp array to the range low to high in the original array.

Modifications in merge() and mergeSort():

*   In order to count the number of pairs, we will keep a count variable, cnt, initialized to 0 beforehand inside the merge().
*   While comparing a[left] and a[right] in the 3rd step of merge(), if a[left] > a[right], we will simply add this line:
    cnt += mid-left+1 (mid+1 = size of the left half)
*   Now, we will return this cnt from merge() to mergeSort().
*   Inside mergeSort(), we will keep another counter variable that will store the final answer. With this cnt, we will
    add the answer returned from mergeSort() of the left half, mergeSort() of the right half, and merge().
*   Finally, we will return this cnt, as our answer from mergeSort().

Note: The code implementation will further clarify the modifications.

Dry Run: Please refer to the video for a better understanding of the dry run.

Program :
import java.util.ArrayList;

public class InversionInArrayOptimalApproach {
    public static void main(String[] args) {
        long[] a = {5, 4, 3, 2, 1};
        int n = 5;
        long cnt = numberOfInversions(a, n);
        System.out.println("The number of inversions are: " + cnt);
    }

    public static long numberOfInversions(long arr[], int n) {
        return mergeSort(arr, 0, n-1);
    }

    public static int mergeSort(long arr[], int low, int high) {
        int cnt = 0;
        if(low >= high) {
            return cnt;
        }

        int mid = (low + high) / 2;

        cnt += mergeSort(arr, low, mid);
        cnt += mergeSort(arr, mid+1, high);
        cnt += merge(arr, low, mid, high);

        return cnt;
    }

    public static int merge(long[] arr, int low, int mid, int high) {
        ArrayList<Long> temp = new ArrayList<>();

        int left = low;
        int right = mid + 1;

        int cnt = 0;

        while(left <= mid && right <= high) {
            if(arr[left] <= arr[right]) {
                temp.add(arr[left]);
                left++;
            }
            else {
                temp.add(arr[right]);
                cnt += (mid - left + 1);
                right++;
            }
        }

        while(left <= mid) {
            temp.add(arr[left]);
            left++;
        }

        while(right <= high) {
            temp.add(arr[right]);
            right++;
        }

        for(int i=low, j=0; i<=high; i++, j++) {
            arr[i] = temp.get(j);
        }

        return cnt;
    }
}

Output :
The number of inversions are: 10

Complexity Analysis
Time Complexity: O(N*logN), where N = size of the given array.
Reason: We are not changing the merge sort algorithm except by adding a variable to it. So, the time complexity is as
same as the merge sort.

Space Complexity: O(N), as in the merge sort We use a temporary array to store elements in sorted order.

---------------------------------------XXX-----------------------------------------------