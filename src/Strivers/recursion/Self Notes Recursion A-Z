Problem Statement:  Introduction to Recursion – Understand Recursion by printing something N times
Level : Easy
Link : https://takeuforward.org/recursion/introduction-to-recursion-understand-recursion-by-printing-something-n-times/

Pre-requisite: The learner must know how to write a basic function in any language and how to make a function call from the main function.

What is Recursion?
It is a phenomenon when a function calls itself indefinitely until a specified condition is fulfilled.
Let’s understand recursion with the help of an illustration :

// image

As we can see in the above image, a function is calling the same function inside its body. Since there is no condition to
stop the recursive calls, the calls will run indefinitely until the stack runs out of memory ( stack overflow ).

What is Stack Overflow in Recursion?

Whenever recursion calls are executed, they’re simultaneously stored in a recursion stack where they wait for the completion
of the recursive function. A recursive function can only be completed if a base condition is fulfilled and the control
returns to the parent function.

But, when there is no base condition given for a particular recursive function, it gets called indefinitely which results
in a Stack Overflow i.e, exceeding the memory limit of the recursion stack and hence the program terminates giving a
Segmentation Fault error.

The illustration above also represents the case of a Stack Overflow as there is no terminating condition for recursion
to stop, hence it will also result in a memory limit exceeded error.

// image

Base Condition

It is the condition that is written in a recursive function in order for it to get completed and not to run infinitely.
After encountering the base condition, the function terminates and returns back to its parent function simultaneously.

To get a better understanding of how the base condition is an integral part of recursive functions, let us see an
example below :

Let’s say we have to print integers starting from 0 till 2 only, this will be how the pseudocode for it will look like

int count = 0;
void func(){

   if(count == 3 ) return;
   print(count);
   count++;
   func();

}

main()
{

  print();

}

According to this pseudocode, the function will increment and print the value of count and then return when the base
condition becomes true i.e, it will only print 0,1,2 and 3 and then execution gets completed.

Recursive code for printing numbers from 0 to 3 :

class Recursion {
    static int cnt = 0;
    static void print(){

         // Base Condition.
         if(cnt == 3 ) return;
         System.out.println(cnt);

         // Count incremented.
         cnt = cnt+1;
         print();

    }
    public static void main(String[] args) {
        print();
    }
}

Output

0
1
2

Recursive Tree

A recursive tree is basically a representative form of recursion which depicts how functions are called and returned as
a series of events happening consecutively. It is a pictorial description of the process of recursion as
illustrated below :

// image

When a recursive call gets completed, the control returns back to its parent function which is then further executed until the last function waiting in the recursive stack returns.

As a summary of the lecture, the basics of recursion such as the following were clear to us :

What is Recursion
Base Condition
Stack Overflow / Stack Space
Recursion Tree


-------------------------------------- XX ---------------------------------------

Problem Statement:  Print Name N times using Recursion
Level : Easy
Link : https://takeuforward.org/recursion/print-name-n-times-using-recursion/

Prerequisite: The learner must know how to write a simple function in any language with parameters.

Now, after understanding the basics of recursion, the recursion tree, and the base case of recursion we can solve some basic
problems of recursion which would strengthen our concepts and make us understand how recursion functions at its core.

Problem: Print your Name N times using recursion

Since in this problem, there is no count that can be incremented each time we call a function, how can we keep a track
of how many times we have printed the name?

For this problem, we’re going to be using a function along with parameters in which we can keep track of the number of
times we’ve printed something. To understand this problem better, let us see the pseudocode below for this :

void func( i, n )
{
   if(i>n) return;
 print(“Raj”);
   f( i+1,N );
}
main()
{
  int n;
  input(n);
  f(1,n);
}

We can clearly see in this pseudocode that we first call the function when the value of i is 1 and then print the name
and increment i by 1 inside the parameter of the function and make a call again. But, we know that this will go on
forever as i will be increasing continuously after every function call. So, to avoid this we put a base condition
that if i exceeds n, then simply terminate the current recursive call and return to the previous call.

In this way, the text that we want to print would be printed n times and as soon as we exceed the count of printing
by n, the function terminates.

Recursion Tree for the following problem can be represented as follows :

// image

class Recursion {

    static void func(int i, int n){

            // Base Condition.
            if(i>n) return;
            System.out.println("Raj");

            // Function call to print till i increments.
            func(i+1,n);

    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 4.
       int n = 4;
       func(1,n);
    }
}

Output

Raj
Raj
Raj
Raj

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable
line that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls
waiting to get completed and that would make it an O(N) recursion stack space }.

-------------------------------------- XX ---------------------------------------


Problem Statement:  Print 1 to N using Recursion
Level : Easy
Link : https://takeuforward.org/recursion/print-1-to-n-using-recursion/

Prerequisite: The learner must know how to write a simple function in any language with parameters.

Now, after understanding the basics of recursion, the recursion tree, and the base case of recursion we can solve some
basic problems of recursion which would strengthen our concepts and make us understand how recursion functions at
its core. In this article, we’ll print integers from 1 to N without using any Global Variable but by using function
parameters.

Problem: Print from 1 to N using Recursion

Since in this problem, there is no global variable that can be incremented each time we call a function, how can we keep a
track of the number of integers being printed on the output screen?

For this problem, we’re going to be using a function along with parameters that get incremented with each function call
through which we can keep track of the integer count while printing. To understand this problem better, let us see the
pseudocode below for this :

void func( i, n )
{
   if(i>n) return;
 print(i);
   f( i+1,N );
}
main()
{
  int n;
  input(n);
  f(1,n);
}

We can clearly see in this pseudocode that we first call the function when the value of i is 1 and then print the value
of i and increment i by 1 inside the parameter of the function and make a call again. But, we know that this will go
on forever as i will be increasing continuously after every function call. So, to avoid this we put a base condition
that if i exceeds n, then simply terminate the current recursive call and return to the previous call.

In this way, all the integers from 1 to N would get printed and as soon as we exceed the count of printing by n, the
function terminates.

Recursion Tree for the following problem can be represented as follows :

// image

class Recursion {

    static void func(int i, int n){

            // Base Condition.
            if(i>n) return;
            System.out.println(i);

            // Function call to print i till i increments to n.
            func(i+1,n);

    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 4.
       int n = 4;
       func(1,n);
    }
}
Output

1
2
3
4

Alternate Approach for printing integers from 1 to N (using Backtracking)

This is an alternative approach for printing the integers from 1 to N using recursion. In the previous approach, we used
forward recursion but in this approach, we will be using backward recursion. The only change from the previous approach
here will be that the print line would be kept after the function call inside the recursive function contrary to the
previous approach. The function would be called for printing (i-1) integers and the nth integer would be printed.

To get a clear understanding of what this approach is like let’s see the pseudocode for this :

void func( i, n )
{
   if(i<1) return;
 f( i-1,N );
print(i);

}
main()
{
  int n;
  input(n);
  f(n,n);
}

We can clearly see in this pseudocode that we first call the function when the value of i is N and then make a call again
inside this function for printing (n-1) integers and after this we print N. But, we know that this will go on forever as
i will be decreasing continuously after every function call. So, to avoid this we put a base condition that if i is less
than n, then simply terminate the current recursive call and return to the previous call.

In this way, all the integers from 1 to N would get printed and as soon as i becomes less than n, the function call terminates.

Recursion Tree for the following approach can be represented as follows :

// image

class Recursion {

    static void func(int i, int n){

            // Base Condition.
            if(i<1) return;

            // Function call to print(n-1) integers.
            func(i-1,n);
            System.out.println(i);

    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 4.
       int n = 4;
       func(n,n);
    }
}

Output:

1
2
3
4

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable line
that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls waiting
to get completed and that would make it an O(N) recursion stack space }.

-------------------------------------- XX ---------------------------------------

Problem Statement:  Print N to 1 using Recursion
Level : Easy
Link : https://takeuforward.org/recursion/print-n-to-1-using-recursion/

Prerequisite: The learner must know how to write a simple function in any language with parameters.

Now, after understanding the basics of recursion, the recursion tree, and the base case of recursion we can solve some basic
problems of recursion which would strengthen our concepts and make us understand how recursion functions at its core.
In this article, we’ll print integers from N to 1 without using any Global Variable but by using function parameters.

Problem: Print from N to 1 using Recursion

Since in this problem, there is no global variable that can be decremented each time we call a function, how can we
keep a track of the number of integers being printed on the output screen?

For this problem, we’re going to be using a function along with parameters that get decremented with each function
call through which we can keep track of the integer count while printing. To understand this problem better, let us
see the pseudocode below for this :

void func( i, n )
{
   if(i<1) return;
 print(i);
   f( i-1,N );
}
main()
{
  int n;
  input(n);
  f(n,n);
}

We can clearly see in this pseudocode that we first call the function when the value of i is n and then print the value
of i and decrement i by 1 inside the parameter of the function and make a call again. But, we know that this will go
on forever as i will be decreasing continuously after every function call. So, to avoid this we put a base condition
that if i is less than 1, then simply terminate the current recursive call and return to the previous call.

In this way, all the integers from N to 1 would get printed and as soon as the count becomes less than 1, the function
terminates.

Recursion Tree for the following problem can be represented as follows :

// image

class Recursion {

    static void func(int i, int n){

            // Base Condition.
            if(i<1) return;
            System.out.println(i);

            // Function call to print i till i decrements to 1.
            func(i-1,n);

    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 4.
       int n = 4;
       func(n,n);
    }
}

Output

4
3
2
1

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable line
that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls waiting
to get completed and that would make it an O(N) recursion stack space }.

Alternate Approach for printing integers from N to 1 (using Backtracking)

This is an alternative approach for printing the integers from N to 1 using recursion. In the previous approach, we used
forward recursion but in this approach, we will be using backward recursion. The only change from the previous approach
here will be that the print line would be kept after the function call inside the recursive function contrary to the
previous approach. The function would be called for printing (i+1) integers and the ith integer would be printed.

To get a clear understanding of what this approach is like let’s see the pseudocode for this :

void func( i, n )
{
   if(i>n) return;
 f( i+1,N );
print(i);

}
main()
{
  int n;
  input(n);
  f(1,n);
}

We can clearly see in this pseudocode that we first call the function when the value of i is N and then make a call
again inside this function for printing (n-1) integers and after this, we print N. But, we know that this will go
on forever as i will be decreasing continuously after every function call. So, to avoid this we put a base condition
that if i is less than n, then simply terminate the current recursive call and return to the previous call.

In this way, all the integers from 1 to N would get printed and as soon as i becomes less than n, the function
call terminates.

Recursion Tree for the following approach can be represented as follows :

// image

Code ( Alternate Approach )

class Recursion {

    static void func(int i, int n){

            // Base Condition.
            if(i>n) return;

            // Function call to print(i+1) integers.
            func(i+1,n);
            System.out.println(i);

    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 4.
       int n = 4;
       func(1,n);
    }
}
Output

4
3
2
1

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable
line that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls
waiting to get completed and that would make it an O(N) recursion stack space }.

-------------------------------------- XX ---------------------------------------

Problem Statement:  Sum of first N Natural Numbers
Level : Easy
Link : https://takeuforward.org/data-structure/sum-of-first-n-natural-numbers/

Problem statement: Given a number ‘N’, find out the sum of the first N natural numbers.

Example 1:
Input: N=5
Output: 15
Explanation: 1+2+3+4+5=15

Example 2:
Input: N=6
Output: 21
Explanation: 1+2+3+4+5+6=15

Solution1: Using Loop

Intuition: We can simply add numbers one by one from 1 to N.

For eg. if N = 5, we can add 1+2+3+4+5=15.

We can use a for loop or while loop to achieve the goal.

Approach:

Take a variable sum and initialize it as 0.
Take a for loop and run from 1 to N.
Save the result in sum.

Program :

import java.util.*;

public class tuf {

  public static void main(String[] args) {

    solve(5);
    solve(6);
  }
  public static void solve(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += i;
    }
    System.out.println("The sum of the first " + n + " numbers is: " + sum);
  }
}
Output:

The sum of the first 5 numbers is: 15
The sum of the first 6 numbers is: 21

Time Complexity: O(N)

Space Complexity: O(1)


Solution 2: Using the formula

Intuition: We can use the formula for the sum of N numbers, i.e N(N+1)/2.

For eg: N=5

5(5+1)/2 = 5(6)/2 = 15.

Approach:

Take a variable sum.
Initialize it with N(N+1)/2, where N is a given number.

import java.util.*;

public class tuf {

  public static void main(String[] args) {

    solve(5);
    solve(6);
  }
  public static void solve(int N) {
    int sum = N * (N + 1) / 2;
    System.out.println("The sum of the first " + N + " numbers is: " + sum);
  }
}

Output:

The sum of the first 5 numbers is: 15
The sum of the first 6 numbers is: 21

Time Complexity: O(1)

Space Complexity: O(1)


Recursive way of calculating the sum of first N Natural Numbers:
* Parameterized Way
* Functional Way

1. Parameterized way

In this approach, instead of using a global variable for calculating the sum, we pass the sum in the parameters of the
function each time we add an integer to it during the function call. The sum gets incremented by an ith integer and
i get decremented by 1 in each function call. At the end when i becomes less than 1, we simply return the calculated
sum until that point.

To understand this parameterized approach better, let us have a look at the pseudocode given below:

void func(i,sum)
{
   if(i<1)
   {
     print(sum);
     return;
   }

func(i-1,sum+i);

}

main()
{
   input(n);
   func(n,0);

}
We can clearly see in this pseudocode that we first call the function when the value of sum is 0 and then we
increment the value of sum by i (initially i is n) and decrement i by 1 inside the parameter of the function and
make a call again. But, we know that this will go on forever as i will be decreasing continuously after every function
call. So, to avoid this we put a base condition that if i is less than 1, then simply terminate the current recursive
call and return the calculated sum.

Recursion Tree for the following problem can be represented as follows :

// image

class Recursion {

    static void func(int i, int sum){

            // Base Condition.
            if(i<1){

                System.out.println(sum);
                return;
            }

            // Function call to increment sum by i till i decrements to 1.
            func(i-1,sum+i);


    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 3.
       int n = 3;
       func(n,0);
    }
}

Output :
6

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable line
that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls waiting
to get completed and that would make it an O(N) recursion stack space }.

2. Functional way

This approach is a lot simpler than the parameterized recursion. We can visualize the sum of n natural numbers in the
following way as shown below:

sumOfNaturalNumbers(N) = N + sumOfNaturalNumbers(N-1);

The Sum of N natural numbers would just be the Nth integer added to the Sum of (N-1) natural numbers. The base case can
be visualized as if n decreases to 0, then we return 0 because the sum of 0 natural numbers is 0 only. Here, we’ve just
broken the problem into 2 subparts and the answers of both these subparts would be added and stored in the Sum(n) function
which would then be printed at last.

To understand this functional approach better, let us have a look at the pseudocode given below:

int func(n)
{
   if(n == 0)
   {
     return 0;
   }

return n + func(n-1);

}

main()
{
   input(n);
   func(n);

}

Recursion Tree for the following problem can be represented as follows :

// image

class Recursion {

    static int func(int n){

            // Base Condition.
            if(n == 0){

                return 0;
            }

            // Problem broken down into 2 parts and then combined.
            return n + func(n-1);


    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 3.
       int n = 3;
       System.out.println(func(n));
    }
}

Output

6

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable line
that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls waiting
to get completed and that would make it an O(N) recursion stack space }.

-------------------------------------- XX ---------------------------------------

Problem Statement:  Factorial of a Number : Iterative and Recursive
Level : Easy
Link : https://takeuforward.org/data-structure/factorial-of-a-number-iterative-and-recursive/

Problem Statement: Given a number X,  print its factorial.

To obtain the factorial of a number, it has to be multiplied by all the whole numbers preceding it. More precisely
X! = X*(X-1)*(X-2) … 1.

Note: X  is always a positive number.

Example 1:
Input: X = 5
Output: 120
Explanation: 5! = 5*4*3*2*1

Example 2:
Input: X = 3
Output: 6
Explanation: 3!=3*2*1

Solution 1: Iterative

Approach:

Since the factorial of X  will be the product of the number itself and all its preceding numbers we can run loop i,
from 1 to X. In every iteration current i, is multiplied with the product so far.

public class Main {
   static int factorial(int X) {
      int ans = 1;
      for (int i = 1; i <= X; i++) {
         ans = ans * i;
      }
      return ans;
   }
   public static void main(String[] args) {

      int X = 5;
      int result = factorial(X);
      System.out.println("The factorial of " + X + " is " + result);
   }
}

Output: The factorial of 5 is 120

Time Complexity: O(n)

Space Complexity: O(1)

Solution 2: Recursive

Recursive way of calculating the factorial of first N Numbers (functional way):

The Factorial of a number N can be calculated by multiplying all the natural numbers till the number N. Through this approach,
we can visualize the factorial of n natural numbers in the following way as shown below:

factorial(N) = N * factorial(N-1);
The Factorial of N natural numbers is the Nth integer multiplied by the Factorial of (N-1) natural numbers. The base case
can be visualized as if n decreases to 0, then we return 1 because the factorial of 0 is 1 only. Here, we’ve just broken
the problem into 2 subparts and the answers of both would be multiplied together and stored in the factorial(n) function
which would then be printed at last.

To understand this functional approach better, let us have a look at the pseudocode given below:

int factorial(n)
{
   if(n == 0)
   {
     return 1;
   }

return n * factorial(n-1);

}

main()
{
   input(n);
   factorial(n);

}

Recursion Tree for the following problem can be represented as follows :

// image

class Recursion {

    static int factorial(int n){

            // Base Condition.
            if(n == 0){

                return 1;
            }

            // Problem broken down into 2 parts and then combined.
            return n * factorial(n-1);


    }
    public static void main(String[] args) {

       // Here, let’s take the value of n to be 3.
       int n = 3;
       System.out.println(factorial(n));
    }
}

Output

6

Time Complexity: O(N) { Since the function is being called n times, and for each function, we have only one printable line
that takes O(1) time, so the cumulative time complexity would be O(N) }

Space Complexity: O(N) { In the worst case, the recursion stack space would be full with all the function calls waiting
to get completed and that would make it an O(N) recursion stack space }.


-------------------------------------- XX ---------------------------------------

Reverse a given Array
Problem Statement:   You are given an array. The task is to reverse the array and print it.
Level : Easy
Link : https://takeuforward.org/data-structure/reverse-a-given-array/

Example 1:
Input: N = 5, arr[] = {5,4,3,2,1}
Output: {1,2,3,4,5}
Explanation: Since the order of elements gets reversed the first element will occupy the fifth position, the second
element occupies the fourth position and so on.

Example 2:
Input: N=6 arr[] = {10,20,30,40}
Output: {40,30,20,10}
Explanation: Since the order of elements gets reversed the first element will occupy the fifth position, the second
element occupies the fourth position and so on.

Solution
Disclaimer: Don’t jump directly to the solution, try it out yourself first.

Solution 1: Using an extra array.

Approach: Declare an array,ans[] of the same size as the input array. Iterate from the back of the input array while
storing the elements in ans[]  in opposite direction.

// image

Code :
public class Main {
   //Function to print array
   static void printArray(int ans[], int n) {
      System.out.print("Reversed array is:- \n");
      for (int i = 0; i < n; i++) {
         System.out.print(ans[i] + " ");
      }
   }
   //Function to reverse array using an auxiliary array
   static void reverseArray(int arr[], int n) {
      int[] ans = new int[n];
      for (int i = n - 1; i >= 0; i--) {
         ans[n - i - 1] = arr[i];
      }
      printArray(ans, n);
   }
   public static void main(String[] args) {
      int n = 5;
      int arr[] = { 5, 4, 3, 2, 1};
      reverseArray(arr, n);
   }
}

Output:

The reversed array is:-
1 2 3 4 5

Time Complexity: O(n), single-pass for reversing array.

Space Complexity: O(n), for the extra array used.

Solution 2: Space-optimized iterative method

Approach: Unlike the previous method we use the same array to obtain the result. Follow the steps below.

Keep a pointer p1  at the first index and another p2 at the last index of the array.
Swap the elements pointed by p1 and p2, Post swapping increment p1 and decrement p2.
This process is repeated for only the first n/2 elements where n is the length of array.
Note: Swapping all the n elements instead of n/2 elements leaves the array unaltered.

// image

Code :
public class Main {
   //Function to print array
   static void printArray(int arr[], int n) {
      System.out.print("Reversed array is:- \n");
      for (int i = 0; i < n; i++) {
         System.out.print(arr[i] + " ");
      }
   }
   //Function to reverse array
   static void reverseArray(int arr[], int n) {
      int p1 = 0, p2 = n - 1;
      while (p1 < p2) {
         int tmp = arr[p1];
         arr[p1] = arr[p2];
         arr[p2] = tmp;
         p1++;
         p2--;
      }
      printArray(arr, n);
   }
   public static void main(String[] args) {
      int n = 5;
      int arr[] = { 5, 4, 3, 2, 1};
      reverseArray(arr, n);

   }
}

Output:

The reversed array is:-
1 2 3 4 5

Time Complexity: O(n), single-pass involved.

Space Complexity: O(1)

Solution 3: Recursive method

Approach: The recursive method has an approach almost similar to the iterative one. The approach has been broken down
into some steps for simplicity.

Create a function that takes an array, start index, and end index of the array as parameters.
Swap the elements present  at the start and end index,
The portion of the array left to be reversed is arr[start+1,end-1]. Make a recursive call to reverse the rest of the
array. While calling recursion pass start +1  and ends – 1 as parameters for the shrunk array. Repeat step 2.
Continue recursion as long as the ‘start < end’ condition is satisfied. This is the base case for our recursion.

Code :
public class Main {
   //Function to print array
   static void printArray(int arr[], int n) {
      System.out.print("Reversed array is:- \n");
      for (int i = 0; i < n; i++) {
         System.out.print(arr[i] + " ");
      }
   }
   //Function to reverse array using recursion
   static void reverseArray(int arr[], int start, int end) {
      if (start < end) {
         int tmp = arr[start];
         arr[start] = arr[end];
         arr[end] = tmp;
         reverseArray(arr, start + 1, end - 1);
      }
   }
   public static void main(String[] args) {
      int n = 5;
      int arr[] = { 5, 4, 3, 2, 1};
      reverseArray(arr, 0, n - 1);
      printArray(arr, n);
   }
}

Output:

The reversed array is:-
1 2 3 4 5

Time Complexity: O(n)

Space Complexity: O(1)

Solution 4: Using library function (New Approach)

Approach: C++ and Java have inbuilt functions to reverse an array.

For C++:-

The std::reverse function in C++ is predefined in a header file algorithm.

Syntax: array_name.reverse(BidirectionalIterator first, BidirectionalIterator last)

Bidirectional iterators first and last indicate the starting and ending positions in the array. Elements that lie in this range are reversed. Note that this range includes the first but excludes the last element.

For Java:-

The reverse method in java can be imported from the Collections class present in java.util package.

Note:

Since this method expects an object as a parameter we have to convert the array into a list object using asList().
Java collections require wrapper classes instead of primitive data types. In order to reverse an integer array use Integer instead of int.
Syntax: Collections.reverse(class_obj);

import java.util.*;
public class Main {
   //Function to print array
   static void printArray(Integer arr[], int n) {
      System.out.print("Reversed array is:- \n");
      for (int i = 0; i < n; i++) {
         System.out.print(arr[i] + " ");
      }
   }
   //Reverse array using library function
   static void reverseArray(Integer arr[]) {
      //fetching array as list object
      //reversing the fetched object
      Collections.reverse(Arrays.asList(arr));
   }
   public static void main(String[] args) {
      int n = 5;
      Integer arr[] = {5,4,3,2,1};
      reverseArray(arr);
      printArray(arr, n);
   }
}

Output:

The reversed array is:-
1 2 3 4 5

Time Complexity: O(n)

Space Complexity: O(1)

-------------------------------------- XX ---------------------------------------

Check if the given String is Palindrome or not
Problem Statement: “Given a string, check if the string is palindrome or not.”  A string is said to be palindrome if the reverse of the string
is the same as the string.
Level : Easy
Link : https://takeuforward.org/data-structure/check-if-the-given-string-is-palindrome-or-not/

Example 1:
Input: Str =  “ABCDCBA”
Output: Palindrome
Explanation: String when reversed is the same as string.

Example 2:
Input: Str = “TAKE U FORWARD”
Output: Not Palindrome
Explanation: String when reversed is not the same as string.

Approach:

Run a for loop till half the length of the string in order to check the first and last character of the string.

And check if the first and last elements of the string are equal. And then move both pointers first pointer forward
and last pointer backward.

Here we are achieving this with the help of ‘i’ which moves with them for a loop. First element can be get by
str[i] and last element by str[str.length() – i – 1]). If this condition gets executed then it is not palindrome
and returns false.

If the loop ends after traversing elements till half of the length then, it is Palindrome and returns false.

// image

import java.io.*;
import java.util.Arrays;
class Test {
  static private boolean isPalindrome(String s) {
    int left = 0, right = s.length()-1;
        while(left<right)
        {
            char l = s.charAt(left), r = s.charAt(right);
            if(!Character.isLetterOrDigit(l))
                left++;
            else if(!Character.isLetterOrDigit(r))
                right--;
            else if(Character.toLowerCase(l)!=Character.toLowerCase(r))
                return false;
            else {
                left++;
                right--;
            }
        }
        return true;
  }
  public static void main(String[] args) {
    String str = "ABCDCBA";
    boolean ans = isPalindrome(str);

    if (ans == true) {
      System.out.println("Palindrome");
    } else {
      System.out.println("Not Palindrome");
    }
  }
}

Output: Palindrome

Time Complexity:  O(N)

Space Complexity: O(1)


Recursive Approach:

In this approach, we check the string using functional recursion where firstly, the letters on the two ends of the
string (start, end) are compared to see if they’re the same or not.
If they’re the same then we simply call recursion for the next elements (start+1, end-1) and so on until the start
becomes greater than or equal to the end.
If at any point the start and the end differ, we return false stating that the string is not a palindrome.
Otherwise, if the base condition is reached, then the string is obviously a palindrome and we return true.
Let us understand it through a recursive code:

Code:

class Recursion {

    static boolean palindrome(int i, String s){

            // Base Condition
            // If i exceeds half of the string, means all the elements
            // are compared, we return true.
            if(i>=s.length()/2) return true;

            // If start is not equal to end, not palindrome.
            if(s.charAt(i)!=s.charAt(s.length()-i-1)) return false;

            // If both characters are same, increment i and check start+1 and end-1.
            return palindrome(i+1,s);


    }
    public static void main(String[] args) {

       // Example string.
       String s = "madam";
       System.out.println(palindrome(0,s));
    }
}

Output:

True

Time Complexity: O(N) { Precisely, O(N/2) as we compare the elements N/2 times and swap them}.

Space Complexity: O(1) { The elements of the given array are swapped in place so no extra space is required}.

-------------------------------------- XX ---------------------------------------

Print Fibonacci Series up to Nth term
Problem Statement:  Given an integer N. Print the Fibonacci series up to the Nth term.
Level : Easy
Link : https://takeuforward.org/arrays/print-fibonacci-series-up-to-nth-term/

Example 1:
Input: N = 5
Output: 0 1 1 2 3 5
Explanation: 0 1 1 2 3 5 is the fibonacci series up to 5th term.(0 based indexing)

Example 2:
Input: 6

Output: 0 1 1 2 3 5 8
Explanation: 0 1 1 2 3 5 8 is the fibonacci series upto 6th term.(o based indexing)

Solution 1: Naive approach

Intuition: As we know fib(i) = fib(i-1) + fib(i-2).Simply iterate and go on calculating the ith term in the series.

Approach:

* Take an array say fib of size n+1.The 0th term and 1st term are 0 and 1 respectively.So fib(0)=0 and fib(1)=1.
* Now iterate from 2 to n and calculate fib(n).fib(n)=fib(n-1) + fib(n-2).
* Then print fib(0) + fib(1) + …………fib(n).

public class TUF {
  public static void main(String args[]) {
    int n = 5;
    if (n == 0) {
      System.out.println(0);
    } else {
      int fib[] = new int[n + 1];
      fib[0] = 0;
      fib[1] = 1;
      for (int i = 2; i <= n; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
      }
      System.out.println("The Fibonacci Series up to "+n+"th term:");
      for (int i = 0; i <= n; i++) {
        System.out.print(fib[i] + " ");
      }
    }
  }
}

Output:

The Fibonacci Series up to 5th term:
0 1 1 2 3 5

Time Complexity: O(n)+O(n), for calculating and printing the Fibonacci series.

Space Complexity: O(n), for storing Fibonacci series.

Solution 2: Space optimized

Intuition: For calculating the ith term we only need the last and second last term i.e (i-1)th and (i-2)th term, so we don’t need to maintain the whole array.

Approach:

* Take two variables last and secondLast for storing (i-1)th and (i-2)th term.
* Now iterate from 2 to n and calculate the ith term. ith term is last + secondLast term.
* Then update secondLast term to the last term and the last term to ith term as we iterate.

public class TUF {
  public static void main(String args[]) {
    int n = 5;
    if (n == 0) {
    System.out.println("The Fibonacci Series up to "+n+"th term:");
    System.out.print(0);
    } else {
      int secondLast = 0;
      int last = 1;
      System.out.println("The Fibonacci Series up to "+n+"th term:");
      System.out.print(secondLast + " " + last + " ");
      int cur;
      for (int i = 2; i <= n; i++) {
        cur = last + secondLast;
        secondLast = last;
        last = cur;
        System.out.print(cur + " ");
      }
    }
  }
}

Output:

The Fibonacci Series up to 5th term:
0 1 1 2 3 5

Time Complexity: O(N).As we are iterating over just one for a loop.

Space Complexity: O(1).

Solution 3

Intuition:

In this approach, instead of printing the Fibonacci series till N, we’re going to print the Nth Fibonacci number using
functional recursion with multiple function calls.

One may wonder how multiple-function calls work. Let’s understand through an illustration below:

// image

Similar kinds of multiple-function calls would be used in implementing the Fibonacci series where any Nth Fibonacci
number can be written as a sum of (N-1)th and (N-2)th Fibonacci numbers. So, the function result would look like this:

Fibonacci(N) = Fibonacci(N-1) + Fibonacci(N-2)

Results from both the function calls would be summed and returned to the main function call.

Approach:

Similar to all the recursion problems we’ve seen before, we need a base case in this problem too in order for recursion
to not go infinitely. Here, we notice that the Fibonacci series start from N = 1, where we initialize its value as 1.
Assume Fibonacci(0) = 0. So, Fibonacci(2) = 1+0 = 1 as the Nth Fibonacci number is the sum of the previous two Fibonacci
numbers.
Similarly, we call Fibonacci(N-1) and Fibonacci(N-2) and return their sum. Both the function calls Fibonacci(N-1) and
Fibonacci(N-2) would be computed individually one by one until the base condition is reached for both and then they
return back to the main function.
Let us see the recursion tree for the following problem to get an even better understanding:

// image

class Recursion {

    static int fibonacci(int N){

            // Base Condition.
            if(N <= 1){

                return N;
            }

            // Problem broken down into 2 functional calls
            // and their results combined and returned.
            int last = fibonacci(N-1);
            int slast = fibonacci(N-2);

            return last + slast;


    }
    public static void main(String[] args) {

       // Here, let’s take the value of N to be 4.
       int N = 4;
       System.out.println(fibonacci(N));
    }
}

Time Complexity: O(2^N) { This problem involves two function calls for each iteration which further expands to 4 function
calls and so on which makes worst-case time complexity to be exponential in nature }.

Space Complexity: O(N) { At maximum there could be N function calls waiting in the recursion stack since we need to
calculate the Nth Fibonacci number for which we also need to calculate (N-1) Fibonacci numbers before it }.

-------------------------------------- XX ---------------------------------------
