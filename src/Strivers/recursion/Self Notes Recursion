Recursion
=========

Que 1 : Subset Sum : Sum of all Subsets
Problem Statement:  Given an array print all the sum of the subset generated from it, in the increasing order.
Level : Easy
Link : https://takeuforward.org/data-structure/subset-sum-sum-of-all-subsets/

Example 1:

Input: N = 3, arr[] = {5,2,1}

Output: 0,1,2,3,5,6,7,8

Explanation: We have to find all the subset’s sum and print them.in this case the generated subsets are
[ [], [1], [2], [2,1], [5], [5,1], [5,2]. [5,2,1],
so the sums we get will be  0,1,2,3,5,6,7,8

Input: N=3,arr[]= {3,1,2}
Output: 0,1,2,3,3,4,5,6

Explanation: We have to find all the subset’s sum and print them.in this case the generated subsets are
[ [], [1], [2], [2,1], [3], [3,1], [3,2]. [3,2,1],
so the sums we get will be  0,1,2,3,3,4,5,6

Solution :

Solution 1: Using recursion

Intuition: The main idea is that on every index you have two options either to select the element to add it
to your subset(pick) or not select the element at that index and move to the next index(non-pick).

Approach: Traverse through the array and for each index solve for two arrays, one where you pick the element,
i.e add the element to the sum or don’t pick and move to the next element, recursively, until the base condition.
Here when you reach the end of the array is the base condition.

// Image

Program :

public class SubSetSum {
    public static void main(String args[]) {
        ArrayList< Integer > arr = new ArrayList < > ();
        arr.add(3);
        arr.add(1);
        arr.add(2);
        ArrayList < Integer > ans = subsetSums(arr, arr.size());
        Collections.sort(ans);
        System.out.println("The sum of each subset is ");
        for (int i = 0; i < ans.size(); i++) {
            System.out.print(ans.get(i) + " ");
        }
    }

    static ArrayList<Integer> subsetSums(ArrayList<Integer> arrayList, int N) {
        ArrayList<Integer> subSet = new ArrayList<>();
        subsetSumsHelper(0, 0, arrayList, N, subSet);
        Collections.sort(subSet);
        return subSet;
    }

    static void subsetSumsHelper(int index, int sum, ArrayList<Integer> arrayList, int N, ArrayList<Integer> subSet) {
        if(index == N) {
            subSet.add(sum);
            return;
        }

        // Pick The Element
        subsetSumsHelper(index+1, sum+arrayList.get(index),arrayList, N, subSet);

        // Do Not Pick The Element
        subsetSumsHelper(index+1, sum, arrayList, N, subSet);
    }
}

Output :
The sum of each subset is
0 1 2 3 3 4 5 6

Time Complexity: O(2^n)+O(2^n log(2^n)). Each index has two ways. You can either pick it up or not pick it. So for n index time complexity for O(2^n) and for sorting it will take (2^n log(2^n)).

Space Complexity: O(2^n) for storing subset sums, since 2^n subsets can be generated for an array of size n.

------------------------------- XX -----------------------------------

Que 2 : Subset – II | Print all the Unique Subsets
Problem Statement:  Given an array of integers that may contain duplicates the task is to return all possible subsets. Return only unique subsets and they can be in any order.
Level : Medium
Link : https://takeuforward.org/data-structure/subset-ii-print-all-the-unique-subsets/

Example 1:

Input: array[] = [1,2,2]

Output: [ [ ],[1],[1,2],[1,2,2],[2],[2,2] ]

Explanation: We can have subsets ranging from  length 0 to 3. which are listed above. Also the subset [1,2] appears twice but is printed only once as we require only unique subsets.

Input: array[] = [1]

Output: [ [ ], [1] ]

Explanation: Only two unique subsets are available

Solution 2: Optimal

Approach:

In the previous method, we were taking extra time to store the unique combination with the help of a set.  To make the solution efficient
we will have to decide on a method that will consider only the unique combinations without the help of additional data structure.

Lets  understand  with an example where arr = [1,2,2 ].

Initially start with an empty data structure. In the first recursion, call make a subset of size one, in the next recursion call a subset
of size 2, and so on. But first, in order to make a subset of size one what options do we have?

We can pick up elements from either the first index or the second index or the third index. However, if we have already picked up two
from the second index, picking up two from the third index will make another duplicate subset of size one. Since we are trying to
avoid duplicate subsets we can avoid picking up from the third index. This should give us an intuition that whenever there are
duplicate elements in the array we pick up only the first occurrence.

The next recursion calls will continue from the point the previous one ended.

Let’s summarize:-

Sort the input array.Make a recursive function that takes the input array ,the current subset,the current index and  a list of list/ vector
of vectors to contain the answer.
Try to make a subset of size n during the nth recursion call and consider elements from every index while generating the combinations.
Only pick up elements that are appearing for the first time during a recursion call to avoid duplicates.
Once an element is picked up, move to the next index.The recursion will terminate when the end of array is reached.While returning
backtrack by removing the last element that was inserted.

public class SubSetSum {
    public static void main(String args[]) {
        ArrayList< Integer > arr = new ArrayList < > ();
        arr.add(3);
        arr.add(1);
        arr.add(2);
        ArrayList < Integer > ans = subsetSums(arr, arr.size());
        Collections.sort(ans);
        System.out.println("The sum of each subset is ");
        for (int i = 0; i < ans.size(); i++) {
            System.out.print(ans.get(i) + " ");
        }
    }

    static ArrayList<Integer> subsetSums(ArrayList<Integer> arrayList, int N) {
        ArrayList<Integer> subSet = new ArrayList<>();
        subsetSumsHelper(0, 0, arrayList, N, subSet);
        Collections.sort(subSet);
        return subSet;
    }

    static void subsetSumsHelper(int index, int sum, ArrayList<Integer> arrayList, int N, ArrayList<Integer> subSet) {
        if(index == N) {
            subSet.add(sum);
            return;
        }

        // Pick The Element
        subsetSumsHelper(index+1, sum+arrayList.get(index),arrayList, N, subSet);

        // Do Not Pick The Element
        subsetSumsHelper(index+1, sum, arrayList, N, subSet);
    }
}


Output :
[[]  [1]  [1  2]  [2]]

Time Complexity: O(2^n) for generating every subset and O(k)  to insert every subset in another data structure if the average length
of every subset is k. Overall O(k * 2^n).

Space Complexity: O(2^n * k) to store every subset of average length k. Auxiliary space is O(n)  if n is the depth of the recursion tree.

------------------------------- XX -----------------------------------

Que 3 : Combination Sum – 1
Problem Statement:
Given an array of distinct integers and a target, you have to return the list of all unique combinations where the chosen numbers sum
to target. You may return the combinations in any order.

The same number may be chosen from the given array an unlimited number of times. Two combinations are unique if the frequency of at
least one of the chosen numbers is different.

It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.

Level : Medium
Link : https://takeuforward.org/data-structure/combination-sum-1/

Example 1:

Input: array = [2,3,6,7], target = 7

Output: [[2,2,3],[7]]

Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
             7 is a candidate, and 7 = 7.
             These are the only two combinations.

Example 2:

Input: array = [2], target = 1

Output: []

Explanation: No combination is possible.


Solution: Recursion

Intuition:

For questions like printing combinations or subsequences, the first thing that should strike your mind is recursion.

How to think recursively?

Whenever the problem is related to picking up elements from an array to form a combination, start thinking about the “pick and non-pick”
approach.

Approach:

Defining recursive function:

// image

Initially, the index will be 0, target as given and the data structure(vector or list) will be empty

Now there are 2 options viz to pick or not pick the current index element.

If you pick the element, again come back at the same index as multiple occurrences of the same element is possible so the target reduces
to target – arr[index] (where target -arr[index]>=0)and also insert the current element into the data structure.

If you decide not to pick the current element, move on to the next index and the target value stays as it is. Also, the current element
is not inserted into the data structure.

While backtracking makes sure to pop the last element as shown in the recursion tree below.

Keep on repeating this process while index < size of the array for a particular recursion call.

You can also stop the recursion when the target value is 0, but here a generalized version without adding too many conditions is considered.

Using this approach, we can get all the combinations.

Base condition

If index== size of array and  target == 0 include the combination in our answer

Diagrammatic representation for Example 1:
Case 1:
// Image

Case 2:
// Image

Program :

import java.io.*;
import java.util.*;
class Solution {

    private void findCombinations(int ind, int[] arr, int target, List < List < Integer >> ans, List < Integer > ds) {
        if (ind == arr.length) {
            if (target == 0) {
                ans.add(new ArrayList < > (ds));
            }
            return;
        }

        if (arr[ind] <= target) {
            ds.add(arr[ind]);
            findCombinations(ind, arr, target - arr[ind], ans, ds);
            ds.remove(ds.size() - 1);
        }
        findCombinations(ind + 1, arr, target, ans, ds);
    }
    public List < List < Integer >> combinationSum(int[] candidates, int target) {
        List < List < Integer >> ans = new ArrayList < > ();
        findCombinations(0, candidates, target, ans, new ArrayList < > ());
        return ans;
    }
}
public class Main {
    public static void main(String[] args) {
        int arr[] = {2,3,6,7};
        int target = 7;
        Solution sol = new Solution();
        List < List < Integer >> ls = sol.combinationSum(arr, target);
        System.out.println("Combinations are: ");
        for (int i = 0; i < ls.size(); i++) {
            for (int j = 0; j < ls.get(i).size(); j++) {
                System.out.print(ls.get(i).get(j) + " ");
            }
            System.out.println();
        }
    }
}

output :

Combinations are:
2 2 3
7

Time Complexity: O(2^t * k) where t is the target, k is the average length

Reason: Assume if you were not allowed to pick a single element multiple times, every element will have a couple of options: pick or not
pick which is 2^n different recursion calls, also assuming that the average length of every combination generated is k. (to put length k
data structure into another data structure)

Why not (2^n) but (2^t) (where n is the size of an array)?

Assume that there is 1 and the target you want to reach is 10 so 10 times you can “pick or not pick” an element.

Space Complexity: O(k*x), k is the average length and x is the no. of combinations.

------------------------------- XX -----------------------------------

Que 4 : Combination Sum II – Find all unique combinations
Problem Statement:  Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations
in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.
Level : Medium
Link : https://takeuforward.org/data-structure/combination-sum-ii-find-all-unique-combinations/

Note: The solution set must not contain duplicate combinations.

Examples:

Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output:
[
    [1,1,6],
    [1,2,5],
    [1,7],
    [2,6]
]
Explanation: These are the unique combinations whose sum is equal to target.

Example 2:
Input: candidates = [2,5,2,1,2], target = 5
Output: [[1,2,2],[5]]
Explanation: These are the unique combinations whose sum is equal to target.

Solution 1: Using extra space and time complexity
Approach:
Defining the Recursive Function:

// image

Before starting the recursive call make sure to sort the elements because the ans should contain the combinations in sorted
order and should not be repeated.

Initially, We start with the index 0, At index 0 we have n – 1 way to pick the first element of our subsequence.

Check if the current index value can be added to our ds. If yes add it to the ds and move the index by 1. while moving the
index skip the consecutive repeated elements because they will form duplicate sequences.

Reduce the target by arr[i],call the recursive call for f(idx + 1,target – 1,ds,ans) after the call make sure to pop the element
from the ds.(By seeing the example recursive You will understand).

if(arr[i] > target) then terminate the recursive call because there is no use to check as the array is sorted in the next
recursive call the index will be moving by 1 all the elements to its right will be in increasing order.

Base Condition:

Whenever the target value is zero add the ds to the ans return.

Representation of Recursive call for the example given below:

// image

If we observe the recursive call for f(2,2,[1,1]) when it is returning the ds doesn’t include 1 so make sure to remove it
from ds after the call.

public class CombinationSum2 {
    static void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {
        if (target == 0) {
            ans.add(new ArrayList<>(ds));
            return;
        }

        for (int i = ind; i < arr.length; i++) {
            if (i > ind && arr[i] == arr[i - 1]) {
                continue;
            }

            if (arr[i] > target) {
                break;
            }

            ds.add(arr[i]);
            findCombinations(i + 1, arr, target - arr[i], ans, ds);
            ds.remove(ds.size() - 1);
        }
    }

    public static List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(candidates);
        findCombinations(0, candidates, target, ans, new ArrayList<>());
        return ans;
    }

    public static void main(String args[]) {
        int v[] = {1, 1, 1, 2, 2};
        List<List<Integer>> comb = combinationSum2(v, 4);
        System.out.println(comb.toString().replace(",", " "));
    }
}

Output :
[[1  1  2]  [2  2]]

------------------------------- XX -----------------------------------

Que 5 : Palindrome Partitioning
Problem Statement: You are given a string s, partition it in such a way that every substring is a palindrome. Return all such palindromic partitions of s.
Level : Easy
Link : https://takeuforward.org/data-structure/palindrome-partitioning/

Example 1:

Input: s = “aab”

Output: [ ["a","a","b"], ["aa","b"] ]

Explanation: The first  answer is generated by  making three partitions. The second answer is generated by making two partitions.

// image

Example 2:

Input: s = “aabb”

Output: [ [“a”,”a”,”b”,”b”], [“aa”,”bb”], [“a”,”a”,”bb”], [“aa”,”b”,”b”] ]

Explanation: See Figure

// image

Solution

Approach: The initial idea will be to make partitions to generate substring and check if the substring generated out of the partition
will be a palindrome. Partitioning means we would end up generating every substring and checking for palindrome at every step. Since
this is a repetitive task being done again and again, at this point we should think of recursion. The recursion continues until the
entire string is exhausted. After partitioning, every palindromic substring is inserted in a data structure When the base case has
reached the list of palindromes generated during that recursion call is inserted in a vector of vectors/list of list.

We have already discussed the initial thought process and the basic outline of the solution. The approach will get clearer with an
example.

Say s = “aabb” and assume indexes of string characters to be 0-based. For a better understanding, we have divided recursion into
some steps.

STEP 1: We consider substrings starting from the 0th index.[0,0] is a palindrome, so partition right after the 0th index.[0,1]
is another palindrome, make a partition after 1st index. Beyond this point, other substrings starting from index 0 are “aab”
and “aabb”. These are not palindromes, hence no more. partitions are possible. The strings remaining on the right side of the
partition are used as input to make recursive calls.

// image

STEP 2: Consider the recursive call on the left(refer to image)  where “abb” is the input.[1,1] is a palindrome, make a partition after it.
[1,2] and [1,3] are not palindromes.

// image

STEP 3: Here “bb” is the input.[2,2] as well as [2,3]  are palindromes. Make one partition after the 2nd index and one after the 3rd
index The entire string is exhausted after the 3rd index, so the right recursion ends here. Palindromes generated from the right
recursion are inserted in our answer.

Our answer at this point :[ [“a”,” a”,” bb”] ]

// image

The left recursion will continue with  “b” as its input.[3,3] is a palindrome so one last partition for the left recursion is made after
the 3rd index. Insert the palindromes.

ans = [  [“a”,”a”,”bb”], [ “a”,”a”,”b”,”b”] ]

STEP 4: After the list of palindromic substrings are returned from the left recursive call, continue the same process for the call on
the right that was left to recur. The right recursion is having “bb” as input, something we have already encountered in step 3.
Hence we will repeat the same task which was done in step 3 onwards.

// image

Final answer : [  [“a”,”a”,”bb”], [ “a”,”a”,”b”,”b”] ,[“aa”,”b”,”b”], [“aa”,”bb”] ]

public class PalindromePartitioning {
    public static List<List<String>> partition(String s) {
        List<List<String>> res = new ArrayList<>();
        List<String> path = new ArrayList<>();
        partitionHelper(0, s, path, res);
        return res;
    }

    static void partitionHelper(int index, String s, List<String> path, List<List<String>> res) {
        if (index == s.length()) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = index; i < s.length(); ++i) {
            if (isPalindrome(s, index, i)) {
                path.add(s.substring(index, i + 1));
                partitionHelper(i + 1, s, path, res);
                path.remove(path.size() - 1);
            }
        }
    }

    static boolean isPalindrome(String s, int start, int end) {
        while (start <= end) {
            if (s.charAt(start++) != s.charAt(end--))
                return false;
        }
        return true;
    }

    public static void main(String args[]) {
        String s = "aabb";
        List<List<String>> ans = partition(s);
        int n = ans.size();
        System.out.println("The Palindromic partitions are :-");
        System.out.print(" [ ");
        for (int i = 0; i < ans.size(); i++) {
            System.out.print("[ ");
            for (int j = 0; j < ans.get(i).size(); j++) {
                System.out.print(ans.get(i).get(j) + " ");
            }
            System.out.print("] ");
        }
        System.out.print("]");
    }
}

Output :
The Palindromic partitions are :-
[ [ a a b b ] [ a a bb ] [ aa b b ] [ aa bb ] ]

Time Complexity: O( (2^n) *k*(n/2) )

Reason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting
the palindromes in another data structure, where k  is the average length of the palindrome list.

Space Complexity: O(k * x)

Reason: The space complexity can vary depending upon the length of the answer. k is the average length of the list of palindromes
and if we have x such list of palindromes in our final answer. The depth of the recursion tree is n, so the auxiliary space required
is equal to the O(n).

------------------------------- XX -----------------------------------

