LinkedList
==========

Que 1 : Reverse a Linked List
Problem Statement:  Given the head of a singly linked list, write a program to reverse the linked list,
and return the head pointer to the reversed list.
Level : Easy
Link : https://takeuforward.org/data-structure/reverse-a-linked-list/

Input Format:
head = [3,6,8,10]
This means the given linked list is 3->6->8->10 with head pointer at node 3.

Result:
Output = [10,8,6,3]
This means, after reversal, the list should be 10->8->6->3 with the head pointer at node 10.


Reverse a Linked List: Recursive

Intuition: This approach is very similar to the above 3 pointer approach. In the process of reversing,
the base operation is manipulating the pointers of each node and at the end, the original head should
be pointing towards NULL and the original last node should be the ‘head’ of the reversed Linked List.

Approach:
---------

* In this type of scenario, we first take a dummy node that will be assigned to NULL.
* Then we take a next pointer which will be initialized to head->next and in future iterations, next will
  again be set to head->next
* Now coming to changes on the head node, as we have set the dummy node as NULL and next to head->next,
  we can now update the next pointer of the head to the dummy node.

// Image

* Before moving to the next iteration dummy is set to head and then the head is set to the next node.

// Image

* Now coming to the next iteration: We’ll follow a similar process to set next as head->next and update
  head->next = dummy, a dummy set to head, and head set to next

// Image

* These iterations will keep going while the head of the original Linked List is not NULL, i.e. we’ll
  reach the end of the original Linked List and the Linked List has been reversed.

Program :
public class ReverseLinkedList {
    public static void main(String[] args) {
        ListNode node = new ListNode(1);
        ListNode node2 = new ListNode(2, node);
        ListNode node3 = new ListNode(3, node2);
        ListNode node4 = new ListNode(4, node3);

        ListNode head = node4;

        while (head != null) {
            System.out.print(head.val +" ");
            head = head.next;
        }

        System.out.println();
        System.out.println("Reverse LinkedList = ");

        ListNode reverseHead = reverseLinkedList(node4);

        while (reverseHead != null) {
            System.out.print(reverseHead.val + " ");
            reverseHead = reverseHead.next;
        }
    }

    public static ListNode reverseLinkedList(ListNode head) {
        ListNode newHead = null;

        while (head != null) {
            ListNode next = head.next;
            head.next = newHead;
            newHead = head;
            head = next;
        }

        return newHead;
    }
}

Output :
4 3 2 1
Reverse LinkedList =
1 2 3 4

--------------------------------- XX ---------------------------------


Que 2 : Middle of the Linked List
Problem Statement:  Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes,
return the second middle node.
Level : Easy
Link : https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/


Input Format: ( Pointer / Access to the head of a Linked list )
head = [1,2,3,4,5]

Result: [3,4,5]
( As we will return the middle of Linked list the further linked list will be still available )

Explanation: The middle node of the list is node 3 as in the below image.

// image

Input Format:
Input: head = [1,2,3,4,5,6]

Result: [4,5,6]

Explanation:
Since the list has two middle nodes with values 3 and 4, we return the second one.

// image

Solution :

Solution 2: [Efficient] Tortoise-Hare-Approach

Unlike the above approach, we don’t have to maintain node count here and we will be able to find the
middle node in a single traversal so this approach is more efficient.

Intuition: In the Tortoise-Hare approach, we increment slow ptr by 1 and fast ptr by 2, so if take a close
look fast ptr will travel double that of the slow pointer. So when the fast ptr will be at the end of the
Linked List, slow ptr would have covered half of the Linked List till then. So slow ptr will be pointing
towards the middle of Linked List.

Approach:

1.  Create two pointers slow and fast and initialize them to a head pointer.
2.  Move slow ptr by one step and simultaneously fast ptr by two steps until fast ptr is NULL or next of
    fast ptr is NULL.
3.  When the above condition is met, we can see that the slow ptr is pointing towards the middle of the
    Linked List and hence we can return the slow pointer.

Program :

public class FindMiddleElement {
    public static void main(String[] args) {
        ListNode node = new ListNode(1);
        ListNode node2 = new ListNode(2, node);
        ListNode node3 = new ListNode(3, node2);
        ListNode node4 = new ListNode(4, node3);

        ListNode head = node4;

        while (head != null) {
            System.out.print(head.val +" ");
            head = head.next;
        }

        System.out.println();
        System.out.println("Middle in LinkedList = ");

        ListNode middle = middleLinkedList(node4);

        while (middle != null) {
            System.out.print(middle.val+" ");
            middle = middle.next;
        }
    }

    public static ListNode middleLinkedList(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
}

Output :
4 3 2 1
Middle in LinkedList =
2 1

--------------------------------- XX ---------------------------------

Que 3 : Merge two sorted Linked Lists
Problem Statement:  Given two singly linked lists that are sorted in increasing order of node values, merge
two sorted linked lists and return them as a sorted list. The list should be made by splicing together the nodes of the first two lists.
Level : Easy
Link : https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/

Example 1:

Input Format :
l1 = {3,7,10}, l2 = {1,2,5,8,10}

Output :
{1,2,3,5,7,8,10,10}


Solution 1: Using an externally linked list to store answers.

Approach :

Step 1: Create a new dummy node. It will have the value 0 and will point to NULL respectively. This will be
the head of the new list. Another pointer to keep track of traversals in the new list.

Step 2:  Find the smallest among two nodes pointed by the head pointer of both input lists, and store that
data in a new list created.

Step 3: Move the head pointer to the next node of the list whose value is stored in the new list.

Step 4: Repeat the above steps till any one of the head pointers stores NULL. Copy remaining nodes of the
list whose head is not NULL in the new list.

Dry Run :

Creating a new dummy node. This will help to keep track as the head of the new list to store merged sorted
lists.

// image

Find the smallest among the two pointed by pointers h1 and h2 in each list. Copy that node and insert it
after the dummy node. Here 1 < 3, therefore 1 will be inserted after the dummy node. Move h2 pointer to
next node.

// image

2 < 3, therefore, 2 is copied to another node and inserted at the end of the new list. h2 is moved to the
next node.

// image

5 > 3, so 3 will be copied to another node and inserted at the end. h1 is moved to the next node.

// image

5 < 7, so 5 will be copied to another node and inserted at the end. h2 is moved to the next node.

// image

8 > 7, so 7 will be copied into a new node and inserted at the end. h1 is moved to the next node.

// image

8 < 10, so 8 will be copied into a new node and inserted at the end. h1 is moved to the next node.

// image

10 = 10, so 10 will be copied into a new node and inserted at the end. h2 is now NULL.

// image

Now, list 1 has only nodes that are not inserted in the new list. So, we will insert the remaining nodes
present in list 1 into the list.

// image

dummy->next will result in the head of the new list.

Time Complexity: O(N+M).

Let N be the number of nodes in list l1 and M be the number of nodes in list l2. We have to iterate through
both lists. So, the total time complexity is O(N+M).

Space Complexity: O(N+M).

We are creating another linked list that contains the (N+M) number of nodes in the list. So, space complexity
is O(N+M).


Solution 2: Inplace method without using extra space.

The idea to do it without extra space is to play around with the next pointers of nodes in the two input lists and arrange them in a fashion such that all nodes are linked in increasing order of values.

Approach :

Step 1: Create two pointers, say l1 and l2. Compare the first node of both lists and find the small among the two. Assign pointer l1 to the smaller value node.

Step 2: Create a pointer, say res, to l1. An iteration is basically iterating through both lists till the value pointed by l1 is less than or equal to the value pointed by l2.

Step 3: Start iteration. Create a variable, say, temp. It will keep track of the last node sorted list in an iteration.

Step 4: Once an iteration is complete, link node pointed by temp to node pointed by l2. Swap l1 and l2.

Step 5: If any one of the pointers among l1 and l2 is NULL, then move the node pointed by temp to the next higher value node.

Dry Run :

Created two pointers l1 and l2. Comparing the first node of both lists. Pointing l1 to the smaller one among the two. Create variable res and store the initial value of l1. This ensures the head of the merged sorted list.

// image

Now, start iterating. A variable temp will always be equal to NULL at the start of the iteration.

// image

1 < 3. temp will store nodes pointed by l1. Then move l1 to the next node.

// image

2 < 3. temp will store node l1(2) and then move l1 to the next node.

// image

5 > 3. Now, the very first iteration completes. Now, the temp storing node is connected to the node pointed by l2, i.e 2 links to 3. Swap l1 and l2. Initialize temp to NULL.

// image

The second iteration starts. 3 < 5. So, first store l1(3) in temp then move l1 to the next connected node.

// image

7 > 5. The second iteration stops here. Link node stored in temp node pointed by l2, i.e, 3 links to 5. Swap l1 and l2. temp is assigned to NULL at the start of the third iteration.

// image

5 < 7. temp will store l1(5) and move l1 to the next linked node.

// image

8 > 7. The third iteration stops. Link node stored in temp to node pointed by l2, i.e 5 links to 7. Swap l1 and l2. Assign temp to NULL at the start of the fourth iteration.

// image

7 < 8. temp stores l1(7). l1 moves to the next node.

// image

10 > 8. The fourth iteration stops here. 7 is linked to 8. Swap l1 and l2. The start of the fifth iteration initializes temp to NULL.

// image

8 < 10. temp stores l1(8). l1 moves to the next node.

// image

10 = 10. temp stores l1(10). l1 moves forward and is now equal to NULL.

// image

As l1 is equal to NULL, so complete iteration stops. We link 10, which is stored in variable temp, is linked to 10 pointed by l2.

// image

Hence, we achieved our sorted merge list.

// image

Program :

public class MergeTwoLinkedList {

    public static void main(String[] args) {
        ListNode node = new ListNode(10);
        ListNode node2 = new ListNode(8, node);
        ListNode node3 = new ListNode(4, node2);
        ListNode node4 = new ListNode(3, node3);

        ListNode node5 = new ListNode(9);
        ListNode node6 = new ListNode(7, node5);
        ListNode node7 = new ListNode(5, node6);

        ListNode data = mergeTwoLists(node4, node7);

        while (data != null) {
            System.out.print(data.val +" ");
            data = data.next;
        }
    }

    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }

        if(l2 == null) {
            return l1;
        }

        if(l1.val > l2.val) {
            ListNode temp = l1;
            l1 = l2;
            l2 = temp;
        }

        ListNode res = l1;

        while (l1 != null && l2 != null) {
            ListNode tmp = null;

            while (l1 != null && l1.val <= l2.val) {
                tmp = l1;
                l1 = l1.next;
            }
            tmp.next = l2;

            ListNode temp = l1;
            l1 = l2;
            l2 = temp;
        }

        return res;
    }
}

Output :
3 4 5 7 8 9 10

--------------------------------- XX ---------------------------------

Que 4 : Find intersection of Two Linked Lists
Problem Statement: Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Level : Easy
Link : https://takeuforward.org/data-structure/find-intersection-of-two-linked-lists/

Example 1:
Input:
List 1 = [1,3,1,2,4], List 2 = [3,2,4]
Output:
2
Explanation: Here, both lists intersecting nodes start from node 2.

Example 2:
Input:
List1 = [1,2,7], List 2 = [2,8,1]
Output:
Null
Explanation: Here, both lists do not intersect and thus no intersection node is present.

Brute-Force Approach :
----------------------

Approach: We know intersection means a common attribute present between two entities. Here,
we have linked lists as given entities.

What should be the common attribute for two linked lists?

If you believe a common attribute is a node’s value, then think properly! If we take our example 1,
there we can see both lists have nodes of value 3. But it is not the first intersection node.
So what’s the common attribute?

It is the node itself that is the common attribute. So, the process is as follows:-

1.  Keep any one of the list to check its node present in the other list. Here, we are choosing
    the second list for this task.
2.  Iterate through the other list. Here, it is the first one.
3.  Check if the both nodes are the same. If yes, we got our first intersection node.
4.  If not, continue iteration.
5.  If we did not find an intersection node and completed the entire iteration of the second
    list, then there is no intersection between the provided lists. Hence, return null.

Program :
public class BruteForceApproach {

    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;
        return head;
    }

    static void printList(ListNode head) {
        while (head.next != null) {
            System.out.println(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    static ListNode interSectionNode(ListNode head1, ListNode head2)
    {
        while (head2 != null)
        {
            ListNode temp = head1;
            while (temp != null)
            {
                if(temp == head2) {
                    return head2;
                }
                temp = temp.next;
            }

            head2 = head2.next;
        }
        return null;
    }
    public static void main(String[] args) {
        ListNode head = null;
        head = insertNode(head, 1);
        head = insertNode(head, 3);
        head = insertNode(head, 1);
        head = insertNode(head, 2);
        head = insertNode(head, 4);

        ListNode head1 = head;
        head = head.next.next.next;

        ListNode headSec = null;
        headSec = insertNode(headSec, 3);

        ListNode head2 = headSec;
        headSec.next = head;

        System.out.println("List 1 : ");
        printList(head1);

        System.out.println("List 2 : ");
        printList(head2);

        ListNode answerNode = interSectionNode(head1, head2);
        if(answerNode != null) {
            System.out.println("The intersection Node = "+answerNode.val);
        }
        else {
            System.out.println("No Intersection Found");
        }
    }
}

Output :
List 1 :
1->3->1->2->4
List 2 :
3->2->4
The intersection Node = 2

Time Complexity: O(m*n)
Reason: For each node in list 2 entire lists 1 are iterated.

Space Complexity: O(1)
Reason: No extra space is used.


Better Approach :
-----------------

Approach:

The difference of length method requires various steps to work on it. Using the same concept of
difference of length, a different approach can be implemented. The process is as follows:-

1.  Take two dummy nodes for each list. Point each to the head of the lists.
2.  Iterate over them. If anyone becomes null, point them to the head of the opposite lists and
    continue iterating until they collide.

public class OptimisedApproach {

    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    static ListNode interSectionPresent(ListNode head1, ListNode head2) {
        ListNode d1 = head1;
        ListNode d2 = head2;

        while (d1 != d2) {
            d1 = d1 == null ? head2 : d1.next;
            d2 = d2 == null ? head1 : d2.next;
        }

        return d1;
    }

    static void printList(ListNode head) {
        while(head.next != null) {
            System.out.print(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    public static void main(String[] args) {
        // creation of both lists
        ListNode head = null;
        head=insertNode(head,1);
        head=insertNode(head,3);
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,4);
        ListNode head1 = head;
        head = head.next.next.next;
        ListNode headSec = null;
        headSec=insertNode(headSec,3);
        ListNode head2 = headSec;
        headSec.next = head;
        //printing of the lists
        System.out.print("List1: "); printList(head1);
        System.out.print("List2: "); printList(head2);

        ListNode answerNode = interSectionPresent(head1, head2);

        if(answerNode == null) {
            System.out.println("No Intersection Present");
        }
        else {
            System.out.println("Intersection Present = "+answerNode.val);
        }
    }
}

Output :
List1: 1->3->1->2->4
List2: 3->2->4
Intersection Present = 2

Time Complexity: O(2*max(length of list1,length of list2))
Reason: Uses the same concept of the difference of lengths of two lists.

Space Complexity: O(1)
Reason: No extra data structure is used

--------------------------------- XX ---------------------------------

Que 4 : Detect a Cycle in a Linked List
Problem Statement: Given head, the head of a linked list, determine if the linked list has a
cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.
Level : Easy
Link : https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/

Example 1:
Input:
Head = [1,2,3,4]
Output: true
Explanation: Here, we can see that we can reach node at position 1 again by following the
next pointer. Thus, we return true for this case.

// image

Example 2:
Input:
Head = [1,2,3,4]
Output:false
Explanation: Neither of the nodes present in the given list can be visited again by following
the next pointer. Hence, no loop exists. Thus, we return false.

// image

Solution: Hashing
-----------------

Approach:
We need to keep track of all the nodes we have visited till now so that once we visit the same
node again we can say that a cycle is detected. The process is as follows:

1. Use a hash table for storing nodes.
2. Start iterating through the lists.
3. If the current node is present in the hash table already, this indicates the cycle is present
   in the linked list and returns true.
4. Else move insert the node in the hash table and move ahead.
5. If we reach the end of the list, which is NULL, then we can say that the given list does not
   have a cycle in it and hence we return false.

Program :
public class BruteForce {
    static ListNode insertNode(ListNode head,int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    //utility function to create cycle
    static void createCycle(ListNode head, int a, int b) {
        int cnta = 0,cntb = 0;
        ListNode p1 = head;
        ListNode p2 = head;
        while (cnta != a || cntb != b) {
            if (cnta != a) {
                p1 = p1.next;
                ++cnta;
            }
            if (cntb != b) {
                p2 = p2.next;
                ++cntb;
            }
        }
        p2.next = p1;
    }

    public static void main(String[] args) {
        ListNode head = null;
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);

        createCycle(head,1,3);

        if(cycleDetect(head) == true)
            System.out.println("Cycle detected");
        else
            System.out.println("Cycle not detected");
    }

    static boolean cycleDetect(ListNode head) {
        HashSet<ListNode> hashSet = new HashSet<ListNode>();

        while (head != null) {
            if(hashSet.contains(head)) {
                return true;
            }
            hashSet.add(head);
            head = head.next;
        }

        return false;
    }
}

Output: Cycle detected

Time Complexity: O(N)
Reason: Entire list is iterated once.

Space Complexity: O(N)
Reason: All nodes present in the list are stored in a hash table.

Solution: Slow and Faster Pointer
---------------------------------

Approach:
We will use two pointers with different steps forward. The process is as follows:-

1. We will take two pointers, namely fast and slow. Fast pointer takes 2 steps ahead and
   slow pointer takes 2 points ahead.
2. Iterate through the list until the fast pointer is equal to NULL. This is because NULL
   indicates that there is no cycle present in the given list.
3. Cycle can be detected when fast and slow pointers collide.

public class Optimal {
    static ListNode insertNode(ListNode head,int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    //utility function to create cycle
    static void createCycle(ListNode head, int a, int b) {
        int cnta = 0,cntb = 0;
        ListNode p1 = head;
        ListNode p2 = head;
        while (cnta != a || cntb != b) {
            if (cnta != a) {
                p1 = p1.next;
                ++cnta;
            }
            if (cntb != b) {
                p2 = p2.next;
                ++cntb;
            }
        }
        p2.next = p1;
    }

    public static void main(String[] args) {
        ListNode head = null;
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);

        createCycle(head,1,3);

        if(cycleDetect(head) == true)
            System.out.println("Cycle detected");
        else
            System.out.println("Cycle not detected");
    }

    static boolean cycleDetect(ListNode head) {
        if(head == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast) {
                return true;
            }
        }

        return false;
    }
}

Output: Cycle detected

Time Complexity: O(N)
Reason: In the worst case, all the nodes of the list are visited.

Space Complexity: O(1)
Reason: No extra data structure is used.

--------------------------------- XX ---------------------------------