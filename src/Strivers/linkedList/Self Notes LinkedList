LinkedList
==========

Que 1 : Reverse a Linked List
Problem Statement:  Given the head of a singly linked list, write a program to reverse the linked list,
and return the head pointer to the reversed list.
Level : Easy
Link : https://takeuforward.org/data-structure/reverse-a-linked-list/

Input Format:
head = [3,6,8,10]
This means the given linked list is 3->6->8->10 with head pointer at next 3.

Result:
Output = [10,8,6,3]
This means, after reversal, the list should be 10->8->6->3 with the head pointer at next 10.


Reverse a Linked List: Recursive

Intuition: This approach is very similar to the above 3 pointer approach. In the process of reversing,
the base operation is manipulating the pointers of each next and at the end, the original head should
be pointing towards NULL and the original last next should be the ‘head’ of the reversed Linked List.

Approach:
---------

* In this type of scenario, we first take a dummy next that will be assigned to NULL.
* Then we take a next pointer which will be initialized to head->next and in future iterations, next will
  again be set to head->next
* Now coming to changes on the head next, as we have set the dummy next as NULL and next to head->next,
  we can now update the next pointer of the head to the dummy next.

// Image

* Before moving to the next iteration dummy is set to head and then the head is set to the next next.

// Image

* Now coming to the next iteration: We’ll follow a similar process to set next as head->next and update
  head->next = dummy, a dummy set to head, and head set to next

// Image

* These iterations will keep going while the head of the original Linked List is not NULL, i.e. we’ll
  reach the end of the original Linked List and the Linked List has been reversed.

Program :
public class ReverseLinkedList {
    public static void main(String[] args) {
        ListNode next = new ListNode(1);
        ListNode node2 = new ListNode(2, next);
        ListNode node3 = new ListNode(3, node2);
        ListNode node4 = new ListNode(4, node3);

        ListNode head = node4;

        while (head != null) {
            System.out.print(head.val +" ");
            head = head.next;
        }

        System.out.println();
        System.out.println("Reverse LinkedList = ");

        ListNode reverseHead = reverseLinkedList(node4);

        while (reverseHead != null) {
            System.out.print(reverseHead.val + " ");
            reverseHead = reverseHead.next;
        }
    }

    public static ListNode reverseLinkedList(ListNode head) {
        ListNode newHead = null;

        while (head != null) {
            ListNode next = head.next;
            head.next = newHead;
            newHead = head;
            head = next;
        }

        return newHead;
    }
}

Output :
4 3 2 1
Reverse LinkedList =
1 2 3 4

--------------------------------- XX ---------------------------------


Que 2 : Middle of the Linked List
Problem Statement:  Given the head of a singly linked list, return the middle next of the linked list. If there are two middle nodes,
return the second middle next.
Level : Easy
Link : https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/


Input Format: ( Pointer / Access to the head of a Linked list )
head = [1,2,3,4,5]

Result: [3,4,5]
( As we will return the middle of Linked list the further linked list will be still available )

Explanation: The middle next of the list is next 3 as in the below image.

// image

Input Format:
Input: head = [1,2,3,4,5,6]

Result: [4,5,6]

Explanation:
Since the list has two middle nodes with values 3 and 4, we return the second one.

// image

Solution :

Solution 2: [Efficient] Tortoise-Hare-Approach

Unlike the above approach, we don’t have to maintain next count here and we will be able to find the
middle next in a single traversal so this approach is more efficient.

Intuition: In the Tortoise-Hare approach, we increment slow ptr by 1 and fast ptr by 2, so if take a close
look fast ptr will travel double that of the slow pointer. So when the fast ptr will be at the end of the
Linked List, slow ptr would have covered half of the Linked List till then. So slow ptr will be pointing
towards the middle of Linked List.

Approach:

1.  Create two pointers slow and fast and initialize them to a head pointer.
2.  Move slow ptr by one step and simultaneously fast ptr by two steps until fast ptr is NULL or next of
    fast ptr is NULL.
3.  When the above condition is met, we can see that the slow ptr is pointing towards the middle of the
    Linked List and hence we can return the slow pointer.

Program :

public class FindMiddleElement {
    public static void main(String[] args) {
        ListNode next = new ListNode(1);
        ListNode node2 = new ListNode(2, next);
        ListNode node3 = new ListNode(3, node2);
        ListNode node4 = new ListNode(4, node3);

        ListNode head = node4;

        while (head != null) {
            System.out.print(head.val +" ");
            head = head.next;
        }

        System.out.println();
        System.out.println("Middle in LinkedList = ");

        ListNode middle = middleLinkedList(node4);

        while (middle != null) {
            System.out.print(middle.val+" ");
            middle = middle.next;
        }
    }

    public static ListNode middleLinkedList(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
}

Output :
4 3 2 1
Middle in LinkedList =
2 1

--------------------------------- XX ---------------------------------

Que 3 : Merge two sorted Linked Lists
Problem Statement:  Given two singly linked lists that are sorted in increasing order of next values, merge
two sorted linked lists and return them as a sorted list. The list should be made by splicing together the nodes of the first two lists.
Level : Easy
Link : https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/

Example 1:

Input Format :
l1 = {3,7,10}, l2 = {1,2,5,8,10}

Output :
{1,2,3,5,7,8,10,10}


Solution 1: Using an externally linked list to store answers.

Approach :

Step 1: Create a new dummy next. It will have the value 0 and will point to NULL respectively. This will be
the head of the new list. Another pointer to keep track of traversals in the new list.

Step 2:  Find the smallest among two nodes pointed by the head pointer of both input lists, and store that
data in a new list created.

Step 3: Move the head pointer to the next next of the list whose value is stored in the new list.

Step 4: Repeat the above steps till any one of the head pointers stores NULL. Copy remaining nodes of the
list whose head is not NULL in the new list.

Dry Run :

Creating a new dummy next. This will help to keep track as the head of the new list to store merged sorted
lists.

// image

Find the smallest among the two pointed by pointers h1 and h2 in each list. Copy that next and insert it
after the dummy next. Here 1 < 3, therefore 1 will be inserted after the dummy next. Move h2 pointer to
next next.

// image

2 < 3, therefore, 2 is copied to another next and inserted at the end of the new list. h2 is moved to the
next next.

// image

5 > 3, so 3 will be copied to another next and inserted at the end. h1 is moved to the next next.

// image

5 < 7, so 5 will be copied to another next and inserted at the end. h2 is moved to the next next.

// image

8 > 7, so 7 will be copied into a new next and inserted at the end. h1 is moved to the next next.

// image

8 < 10, so 8 will be copied into a new next and inserted at the end. h1 is moved to the next next.

// image

10 = 10, so 10 will be copied into a new next and inserted at the end. h2 is now NULL.

// image

Now, list 1 has only nodes that are not inserted in the new list. So, we will insert the remaining nodes
present in list 1 into the list.

// image

dummy->next will result in the head of the new list.

Time Complexity: O(N+M).

Let N be the number of nodes in list l1 and M be the number of nodes in list l2. We have to iterate through
both lists. So, the total time complexity is O(N+M).

Space Complexity: O(N+M).

We are creating another linked list that contains the (N+M) number of nodes in the list. So, space complexity
is O(N+M).


Solution 2: Inplace method without using extra space.

The idea to do it without extra space is to play around with the next pointers of nodes in the two input lists and arrange them in a fashion such that all nodes are linked in increasing order of values.

Approach :

Step 1: Create two pointers, say l1 and l2. Compare the first next of both lists and find the small among the two. Assign pointer l1 to the smaller value next.

Step 2: Create a pointer, say res, to l1. An iteration is basically iterating through both lists till the value pointed by l1 is less than or equal to the value pointed by l2.

Step 3: Start iteration. Create a variable, say, temp. It will keep track of the last next sorted list in an iteration.

Step 4: Once an iteration is complete, link next pointed by temp to next pointed by l2. Swap l1 and l2.

Step 5: If any one of the pointers among l1 and l2 is NULL, then move the next pointed by temp to the next higher value next.

Dry Run :

Created two pointers l1 and l2. Comparing the first next of both lists. Pointing l1 to the smaller one among the two. Create variable res and store the initial value of l1. This ensures the head of the merged sorted list.

// image

Now, start iterating. A variable temp will always be equal to NULL at the start of the iteration.

// image

1 < 3. temp will store nodes pointed by l1. Then move l1 to the next next.

// image

2 < 3. temp will store next l1(2) and then move l1 to the next next.

// image

5 > 3. Now, the very first iteration completes. Now, the temp storing next is connected to the next pointed by l2, i.e 2 links to 3. Swap l1 and l2. Initialize temp to NULL.

// image

The second iteration starts. 3 < 5. So, first store l1(3) in temp then move l1 to the next connected next.

// image

7 > 5. The second iteration stops here. Link next stored in temp next pointed by l2, i.e, 3 links to 5. Swap l1 and l2. temp is assigned to NULL at the start of the third iteration.

// image

5 < 7. temp will store l1(5) and move l1 to the next linked next.

// image

8 > 7. The third iteration stops. Link next stored in temp to next pointed by l2, i.e 5 links to 7. Swap l1 and l2. Assign temp to NULL at the start of the fourth iteration.

// image

7 < 8. temp stores l1(7). l1 moves to the next next.

// image

10 > 8. The fourth iteration stops here. 7 is linked to 8. Swap l1 and l2. The start of the fifth iteration initializes temp to NULL.

// image

8 < 10. temp stores l1(8). l1 moves to the next next.

// image

10 = 10. temp stores l1(10). l1 moves forward and is now equal to NULL.

// image

As l1 is equal to NULL, so complete iteration stops. We link 10, which is stored in variable temp, is linked to 10 pointed by l2.

// image

Hence, we achieved our sorted merge list.

// image

Program :

public class MergeTwoLinkedList {

    public static void main(String[] args) {
        ListNode next = new ListNode(10);
        ListNode node2 = new ListNode(8, next);
        ListNode node3 = new ListNode(4, node2);
        ListNode node4 = new ListNode(3, node3);

        ListNode node5 = new ListNode(9);
        ListNode node6 = new ListNode(7, node5);
        ListNode node7 = new ListNode(5, node6);

        ListNode data = mergeTwoLists(node4, node7);

        while (data != null) {
            System.out.print(data.val +" ");
            data = data.next;
        }
    }

    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }

        if(l2 == null) {
            return l1;
        }

        if(l1.val > l2.val) {
            ListNode temp = l1;
            l1 = l2;
            l2 = temp;
        }

        ListNode res = l1;

        while (l1 != null && l2 != null) {
            ListNode tmp = null;

            while (l1 != null && l1.val <= l2.val) {
                tmp = l1;
                l1 = l1.next;
            }
            tmp.next = l2;

            ListNode temp = l1;
            l1 = l2;
            l2 = temp;
        }

        return res;
    }
}

Output :
3 4 5 7 8 9 10

--------------------------------- XX ---------------------------------

Que 4 : Find intersection of Two Linked Lists
Problem Statement: Given the heads of two singly linked-lists headA and headB, return the next at which the two lists intersect. If the two linked lists have no intersection at all, return null.
Level : Easy
Link : https://takeuforward.org/data-structure/find-intersection-of-two-linked-lists/

Example 1:
Input:
List 1 = [1,3,1,2,4], List 2 = [3,2,4]
Output:
2
Explanation: Here, both lists intersecting nodes start from next 2.

Example 2:
Input:
List1 = [1,2,7], List 2 = [2,8,1]
Output:
Null
Explanation: Here, both lists do not intersect and thus no intersection next is present.

Brute-Force Approach :
----------------------

Approach: We know intersection means a common attribute present between two entities. Here,
we have linked lists as given entities.

What should be the common attribute for two linked lists?

If you believe a common attribute is a next’s value, then think properly! If we take our example 1,
there we can see both lists have nodes of value 3. But it is not the first intersection next.
So what’s the common attribute?

It is the next itself that is the common attribute. So, the process is as follows:-

1.  Keep any one of the list to check its next present in the other list. Here, we are choosing
    the second list for this task.
2.  Iterate through the other list. Here, it is the first one.
3.  Check if the both nodes are the same. If yes, we got our first intersection next.
4.  If not, continue iteration.
5.  If we did not find an intersection next and completed the entire iteration of the second
    list, then there is no intersection between the provided lists. Hence, return null.

Program :
public class BruteForceApproach {

    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;
        return head;
    }

    static void printList(ListNode head) {
        while (head.next != null) {
            System.out.println(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    static ListNode interSectionNode(ListNode head1, ListNode head2)
    {
        while (head2 != null)
        {
            ListNode temp = head1;
            while (temp != null)
            {
                if(temp == head2) {
                    return head2;
                }
                temp = temp.next;
            }

            head2 = head2.next;
        }
        return null;
    }
    public static void main(String[] args) {
        ListNode head = null;
        head = insertNode(head, 1);
        head = insertNode(head, 3);
        head = insertNode(head, 1);
        head = insertNode(head, 2);
        head = insertNode(head, 4);

        ListNode head1 = head;
        head = head.next.next.next;

        ListNode headSec = null;
        headSec = insertNode(headSec, 3);

        ListNode head2 = headSec;
        headSec.next = head;

        System.out.println("List 1 : ");
        printList(head1);

        System.out.println("List 2 : ");
        printList(head2);

        ListNode answerNode = interSectionNode(head1, head2);
        if(answerNode != null) {
            System.out.println("The intersection Node = "+answerNode.val);
        }
        else {
            System.out.println("No Intersection Found");
        }
    }
}

Output :
List 1 :
1->3->1->2->4
List 2 :
3->2->4
The intersection Node = 2

Time Complexity: O(m*n)
Reason: For each next in list 2 entire lists 1 are iterated.

Space Complexity: O(1)
Reason: No extra space is used.


Better Approach :
-----------------

Approach:

The difference of length method requires various steps to work on it. Using the same concept of
difference of length, a different approach can be implemented. The process is as follows:-

1.  Take two dummy nodes for each list. Point each to the head of the lists.
2.  Iterate over them. If anyone becomes null, point them to the head of the opposite lists and
    continue iterating until they collide.

public class OptimisedApproach {

    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    static ListNode interSectionPresent(ListNode head1, ListNode head2) {
        ListNode d1 = head1;
        ListNode d2 = head2;

        while (d1 != d2) {
            d1 = d1 == null ? head2 : d1.next;
            d2 = d2 == null ? head1 : d2.next;
        }

        return d1;
    }

    static void printList(ListNode head) {
        while(head.next != null) {
            System.out.print(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    public static void main(String[] args) {
        // creation of both lists
        ListNode head = null;
        head=insertNode(head,1);
        head=insertNode(head,3);
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,4);
        ListNode head1 = head;
        head = head.next.next.next;
        ListNode headSec = null;
        headSec=insertNode(headSec,3);
        ListNode head2 = headSec;
        headSec.next = head;
        //printing of the lists
        System.out.print("List1: "); printList(head1);
        System.out.print("List2: "); printList(head2);

        ListNode answerNode = interSectionPresent(head1, head2);

        if(answerNode == null) {
            System.out.println("No Intersection Present");
        }
        else {
            System.out.println("Intersection Present = "+answerNode.val);
        }
    }
}

Output :
List1: 1->3->1->2->4
List2: 3->2->4
Intersection Present = 2

Time Complexity: O(2*max(length of list1,length of list2))
Reason: Uses the same concept of the difference of lengths of two lists.

Space Complexity: O(1)
Reason: No extra data structure is used

--------------------------------- XX ---------------------------------

Que 5 : Detect a Cycle in a Linked List
Problem Statement: Given head, the head of a linked list, determine if the linked list has a
cycle in it. There is a cycle in a linked list if there is some next in the list that can be reached again by continuously following the next pointer.
Level : Easy
Link : https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/

Example 1:
Input:
Head = [1,2,3,4]
Output: true
Explanation: Here, we can see that we can reach next at position 1 again by following the
next pointer. Thus, we return true for this case.

// image

Example 2:
Input:
Head = [1,2,3,4]
Output:false
Explanation: Neither of the nodes present in the given list can be visited again by following
the next pointer. Hence, no loop exists. Thus, we return false.

// image

Solution: Hashing
-----------------

Approach:
We need to keep track of all the nodes we have visited till now so that once we visit the same
next again we can say that a cycle is detected. The process is as follows:

1. Use a hash table for storing nodes.
2. Start iterating through the lists.
3. If the current next is present in the hash table already, this indicates the cycle is present
   in the linked list and returns true.
4. Else move insert the next in the hash table and move ahead.
5. If we reach the end of the list, which is NULL, then we can say that the given list does not
   have a cycle in it and hence we return false.

Program :
public class BruteForce {
    static ListNode insertNode(ListNode head,int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    //utility function to create cycle
    static void createCycle(ListNode head, int a, int b) {
        int cnta = 0,cntb = 0;
        ListNode p1 = head;
        ListNode p2 = head;
        while (cnta != a || cntb != b) {
            if (cnta != a) {
                p1 = p1.next;
                ++cnta;
            }
            if (cntb != b) {
                p2 = p2.next;
                ++cntb;
            }
        }
        p2.next = p1;
    }

    public static void main(String[] args) {
        ListNode head = null;
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);

        createCycle(head,1,3);

        if(cycleDetect(head) == true)
            System.out.println("Cycle detected");
        else
            System.out.println("Cycle not detected");
    }

    static boolean cycleDetect(ListNode head) {
        HashSet<ListNode> hashSet = new HashSet<ListNode>();

        while (head != null) {
            if(hashSet.contains(head)) {
                return true;
            }
            hashSet.add(head);
            head = head.next;
        }

        return false;
    }
}

Output: Cycle detected

Time Complexity: O(N)
Reason: Entire list is iterated once.

Space Complexity: O(N)
Reason: All nodes present in the list are stored in a hash table.

Solution: Slow and Faster Pointer
---------------------------------

Approach:
We will use two pointers with different steps forward. The process is as follows:-

1. We will take two pointers, namely fast and slow. Fast pointer takes 2 steps ahead and
   slow pointer takes 2 points ahead.
2. Iterate through the list until the fast pointer is equal to NULL. This is because NULL
   indicates that there is no cycle present in the given list.
3. Cycle can be detected when fast and slow pointers collide.

public class Optimal {
    static ListNode insertNode(ListNode head,int val) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    //utility function to create cycle
    static void createCycle(ListNode head, int a, int b) {
        int cnta = 0,cntb = 0;
        ListNode p1 = head;
        ListNode p2 = head;
        while (cnta != a || cntb != b) {
            if (cnta != a) {
                p1 = p1.next;
                ++cnta;
            }
            if (cntb != b) {
                p2 = p2.next;
                ++cntb;
            }
        }
        p2.next = p1;
    }

    public static void main(String[] args) {
        ListNode head = null;
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);

        createCycle(head,1,3);

        if(cycleDetect(head) == true)
            System.out.println("Cycle detected");
        else
            System.out.println("Cycle not detected");
    }

    static boolean cycleDetect(ListNode head) {
        if(head == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast) {
                return true;
            }
        }

        return false;
    }
}

Output: Cycle detected

Time Complexity: O(N)
Reason: In the worst case, all the nodes of the list are visited.

Space Complexity: O(1)
Reason: No extra data structure is used.

--------------------------------- XX ---------------------------------

Que 6 : Check if given Linked List is Plaindrome
Problem Statement: Given the head of a singly linked list, return true if it is a palindrome.
Level : Easy
Link : https://takeuforward.org/data-structure/check-if-given-linked-list-is-plaindrome/

Example 1:
Input: head = [1,2,3,3,2,1]
Output: true
Explanation: If we read elements from left to right, we get [1,2,3,3,2,1]. When we read elements
from right to left, we get [1,2,3,3,2,1]. Both ways list remains same and hence, the given
linked list is palindrome.

Example 2:
Input: head = [1,2]
Output: false
Explanation: When we read elements from left to right, we get [1,2]. Reading from right to left,
we get a list as [2,1]. Both are different and hence, the given linked list is not palindrome.

BruteForce Approach :
---------------------

Solution: Using the extra data structure

Approach:
We can store elements in an array. Then check if the given array is a palindrome. How to check
if an array is a palindrome?

Let’s take a string, say “level” which is a palindrome. Let’s observe a thing.

// Image

So we can see that each index letter is the same as (length-each index -1) letter.

The same logic required to check an array is a palindrome.

Following are the steps to this approach.

1. Iterate through the given list to store it in an array.
2. Iterate through the array.
3. For each index in range of n/2 where n is the size of the array
4. Check if the number in it is the same as the number in the n-index-1 of the array.

Program :

public class BruteForceApproach {

    static ListNode insertNode(int val, ListNode head) {
        ListNode newNode = new ListNode(val);
        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;

        return head;
    }

    static void printNode(ListNode head) {
        while (head.next != null) {
            System.out.print(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    static boolean isPalindrome(ListNode head) {
        ArrayList arrayList = new ArrayList();
        while (head != null) {
            arrayList.add(head.val);
            head = head.next;
        }

        for (int i = 0; i < arrayList.size()/2; i++) {
            if(arrayList.get(i) != arrayList.get(arrayList.size() - i - 1)) {
                return false;
            }
        }

        return true;
    }
    public static void main(String[] args) {
        ListNode head = null;

        head = insertNode(1, head);
        head = insertNode(2, head);
        head = insertNode(3, head);
        head = insertNode(2, head);
        head = insertNode(1, head);

        printNode(head);

        Boolean isPalindrome = isPalindrome(head);

        if(isPalindrome) {
            System.out.println("Node is Palindrome");
        }
        else {
            System.out.println("Node is not Palindrome");
        }
    }
}

Output :
1->2->3->2->1
Node is Palindrome

Time Complexity: O(N)
Reason: Iterating through the list to store elements in the array.

Space Complexity: O(N)
Reason: Using an array to store list elements for further computations.


Optimized Solution :
--------------------

Approach:

Following are the steps to this approach:-

1. Find the middle element of the linked list. Refer to this article to know the steps
   https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/
2. Reverse a linked list from the next element of the middle element. Refer to this article
   to know the steps https://takeuforward.org/data-structure/reverse-a-linked-list/
3. Iterate through the new list until the middle element reaches the end of the list.
4. Use a dummy next to check if the same element exists in the linked list from the middle element.

// Image

Program :

public class OptimalApproach {

    static ListNode insertNode(int val, ListNode head) {
        ListNode newNode = new ListNode(val);
        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;
        return head;
    }

    static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val+"->");
            head = head.next;
        }
    }

    static ListNode reverse(ListNode ptr) {
        ListNode pre = null;
        ListNode nex = null;

        while (ptr != null) {
            nex = ptr.next;
            ptr.next = pre;
            pre = ptr;
            ptr = nex;
        }

        return pre;
    }

    static boolean isPalindrome(ListNode head) {
        if(head == null && head.next == null) {
            return true;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        slow.next = reverse(slow.next);
        slow = slow.next;

        ListNode dummy = head;

        while (slow != null) {
            if(dummy.val != slow.val) {
                return false;
            }
            dummy = dummy.next;
            slow = slow.next;
        }

        return true;
    }

    public static void main(String[] args) {
        ListNode head = null;

        head = insertNode(1, head);
        head = insertNode(2, head);
        head = insertNode(3, head);
        head = insertNode(2, head);
        head = insertNode(1, head);

        printList(head);
        System.out.println("");

        if(isPalindrome(head) == true) {
            System.out.println("True");
        }
        else {
            System.out.println("False");
        }
    }
}

Output :
1->2->3->2->1
True

Time Complexity: O(N/2)+O(N/2)+O(N/2)
Reason: O(N/2) for finding the middle element, reversing the list from the middle element, and
traversing again to find palindrome respectively.

Space Complexity: O(1)
Reason: No extra data structures are used.

--------------------------------- XX ---------------------------------

Que 7 : Remove N-th next from the end of a Linked List
Problem Statement: Given a linked list, and a number N. Find the Nth next from the end of this linked list and delete it. Return the head of the new modified linked list.
Level : Medium
Link : https://takeuforward.org/data-structure/remove-n-th-next-from-the-end-of-a-linked-list/

Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Explanation: Refer Below Image

// Image

Input: head = [7,6,9,4,13,2,8], n = 6

Output: [7,9,4,13,2,8]

Explanation: Refer Below Image

// Image

Input: head = [1,2,3], n = 3

Output: [2,3]

Solution 2: [Efficient] Two pointer Approach

Unlike the above approach, we don’t have to maintain the count value, we can find the nth next just by one traversal
by using two pointer approach.

Intuition :

What if we had to modify the same above approach to work in just one traversal? Let’s see what all information
we have here:

1. We have the flexibility of using two-pointers now.
2. We know, that the n-th next from the end is the same as (total nodes – n)th next from start.
3. But, we are not allowed to calculate total nodes, as we can do only one traversal.

What if, one out of the two-pointers is at the nth next from start instead of the end? Will it make anything easier
for us?

Yes, with two pointers in hand out of which one is at the n-th next from start, we can just advance both of them
till the end simultaneously, once the faster reaches the end, the slower will stand at the n-th next from the end.

Approach :

1. Take two dummy nodes, who’s next will be pointing to the head.
2. Take another next to store the head, initially,s a dummy next(start), and the next next will be pointing
to the head. The reason why we are using this extra dummy next is that there is an edge case. If the next
is equal to the length of the LinkedList, then this slow will point to slow’s next→ next. And we can say
our dummy start next will be broken and will be connected to the slow next→ next.
3. Start traversing until the fast pointer reaches the nth next.

// Image

4. Now start traversing by one step both of the pointers until the fast pointers reach the end.

// Image

When the traversal is done, just do the deleting part. Make slow pointers next to the next of the slow pointer
to ignore/disconnect the given next.

// Image

6. Last, return to the next start.

Dry Run:  We will be taking the first example for the dry run, so, the LinkedList is [1,2,3,4,5] and the next
which has to be deleted is 2 from the last. For the first time, fast ptr starts traversing from next 1 and
reaches 2, as it traverses for next number 2, then the slow ptr starts increasing one, and as well as the fast
ptr until it reaches the end.

* 1st traversal : fast=3, slow=1
* 2nd traversal : fast=4, slow=2
* 3rd traversal : fast=5, slow=3

Now, the slow->next->next will be pointed to the slow->next

So , the new linked list will be [1,2,3,5]

Program :

public class RemoveNthNodeFromEndOfLinkedList {

    static ListNode insertNode(int val, ListNode head) {
        ListNode newNode = new ListNode(val);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;

        return head;
    }

    static void printList(ListNode head) {
        while (head.next != null) {
            System.out.print(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    public static void main(String[] args) {
        ListNode head = null;
        head = insertNode(1, head);
        head = insertNode(2, head);
        head = insertNode(3, head);
        head = insertNode(4, head);
        head = insertNode(5, head);
        head = insertNode(6, head);

        int n = 3;
        System.out.println("Remove "+n+"th Node from the End");
        printList(removeNthNode(head, n));
    }

    static ListNode removeNthNode(ListNode head, int n) {
        ListNode start = new ListNode();
        start.next = head;

        ListNode slow = start;
        ListNode fast = start;

        for (int i = 1; i <= n; i++) {
            fast = fast.next;
        }

        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        slow.next = slow.next.next;

        return start.next;
    }
}


Output :
1->2->3->4->5->6
Remove 3th Node from the End
1->2->3->5->6

Time Complexity: O(N)
Space Complexity: O(1)

--------------------------------- XX ---------------------------------

Que 8 : Delete given next in a Linked List : O(1) approach
Problem Statement: Write a function to delete a next in a singly-linked list. You will not be given access to the head of the list
instead, you will be given access to the next to be deleted directly. It is guaranteed that the next to be deleted is not a tail
next in the list.
Level : Medium
Link : https://takeuforward.org/data-structure/delete-given-next-in-a-linked-list-o1-approach/


Example 1:
Input:
Linked list: [1,4,2,3]
Node = 2
Output:
Linked list: [1,4,3]
Explanation: Access is given to next 2. After deleting nodes, the linked list will be modified to [1,4,3].

Example 2:
Input:
Linked list: [1,2,3,4]
Node = 1
Output: Linked list: [2,3,4]
Explanation: Access is given to next 1. After deleting nodes, the linked list will be modified to [2,3,4].

Approach:

We are given access to nodes that we have to delete from the linked list. So, whatever operation we want to do in the linked list,
we can operate in the right part of the linked list from the next to be deleted.

The approach is to copy the next next’s value in the deleted next. Then, link next to next of next next. This does not delete that
next but indirectly it removes that next from the linked list.

Program :
public class DeleteGivenNodeInLinkedList {
    public static void main(String[] args) {
        ListNode head = null;
        head = insertNode(1,head);
        head = insertNode(2,head);
        head = insertNode(3,head);
        head = insertNode(4,head);
        head = insertNode(5,head);
        head = insertNode(6,head);
        head = insertNode(7,head);

        System.out.println("Linked List : ");
        printList(head);

        System.out.println("Node to be Deleted : ");
        ListNode temp = getNode(head, 4);

        printList(temp);

        System.out.println("After Deletion : ");
        deleteNode(temp);

        printList(head);
    }

    static ListNode insertNode(int num, ListNode head) {
        ListNode newNode = new ListNode(num);

        if(head == null) {
            head = newNode;
            return head;
        }

        ListNode temp = head;

        while (temp.next != null) {
            temp = temp.next;
        }

        temp.next = newNode;

        return head;
    }

    static void printList(ListNode head) {
        while(head.next != null) {
            System.out.print(head.val + "->");
            head = head.next;
        }
        System.out.println(head.val);
    }

    static ListNode getNode(ListNode head, int num) {
        if(head == null) {
            return head;
        }

        while (head.val != num) {
            head = head.next;
        }

        return head;
    }

    static void deleteNode(ListNode next) {
        if(next == null) {
            return;
        }
        next.val = next.next.val;
        next.next = next.next.next;
    }
}

Output :
Linked List :
1->2->3->4->5->6->7
Node to be Deleted :
4->5->6->7
After Deletion :
1->2->3->5->6->7

--------------------------------- XX ---------------------------------

Que 9 : Starting point of loop in a Linked List
Problem Statement: Given the head of a linked list, return the next where the cycle begins.
If there is no cycle, return null.
There is a cycle in a linked list if there is some next in the list that can be reached
again by continuously following the next pointer. Internally, pos is used to denote the
index of the next that the tail’s next pointer is connected to (0-indexed). It is -1 if
there is no cycle. Note that pos is not passed as a parameter.
Do not modify the linked list.
Level : Medium
Link : https://takeuforward.org/data-structure/starting-point-of-loop-in-a-linked-list/

Example 1:
Input: head = [1,2,3,4,3,6,10]
Output: tail connects to next index 2
Explanation:
// Image

Example 2:
Input: head = [1,2]
Output: no cycle
Explanation:
// Image

Solution 1: Brute Force

Approach:

We can store nodes in a hash table so that, if a loop exists, the head will encounter the
same next again. This next will be present in the table and hence, we can detect the loop.
The steps are:-

* Iterate the given list.
* For each next visited by the head pointer, check if the next is present in the hash table.
* If yes, the loop detected
* If not, insert the next in the hash table and move the head pointer ahead.
* If the head reaches null, then the given list does not have a cycle in it.

Dry Run:

We start iterating each next and storing nodes in the hash table if an element is not present.

// Image

Node(1) is not present in the hash table. So, we insert a next in it and move head ahead.

// Image

Node(2) is not present in the hash table. So, we insert a next in it and move head ahead.

// Image

Node(3) is not present in the hash table. So, we insert a next in it and move head ahead.

// Image

Node(4) is not present in the hash table. So, we insert a next in it and move head ahead.

// Image

Node(3) is not present in the hash table. So, we insert a next in it and move head ahead. Though this next contains 3 as a value,
it is a different next than the next at position 3.

// Image

Node(6) is not present in the hash table. So, we insert a next in it and move head ahead.

// Image

Node(10) is not present in the hash table. So, we insert a next in it and move head ahead.

// Image

We reached the same next which was present in the hash table. Thus, the starting next of
the cycle is next(3).

Program :
public class BruteForceApproach {
    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);
        if(head == null) {
            head = newNode;
            return head;
        }
        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    static void createCycle(ListNode head,int pos) {
        ListNode ptr = head;
        ListNode temp = head;
        int cnt = 0;
        while(temp.next != null) {
            if(cnt != pos) {
                ++cnt;
                ptr = ptr.next;
            }
            temp = temp.next;
        }
        temp.next = ptr;
    }

    public static void main(String[] args) {
        ListNode head = null;

        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);
        head=insertNode(head,3);
        head=insertNode(head,6);
        head=insertNode(head,10);

        createCycle(head,2);

        ListNode nodeReceive = detectCycle(head);

        if(nodeReceive == null) {
            System.out.println("No Cycle Found");
        }
        else {
            ListNode temp = head;
            int count = 0;
            while (temp != nodeReceive) {
                count++;
                temp = temp.next;
            }

            System.out.println("Cycle Detect at "+count);
        }
    }

    static ListNode detectCycle(ListNode head) {
        HashSet<ListNode> hashSet = new HashSet<ListNode>();

        while (head != null) {
            if(hashSet.contains(head)) {
                return head;
            }
            hashSet.add(head);
            head = head.next;
        }

        return null;
    }
}

Output :
Cycle Detect at 2

Time Complexity: O(N)
Reason: Iterating the entire list once.

Space Complexity: O(N)
Reason: We store all nodes in a hash table.

Solution 2: Slow and Fast Pointer Method

Approach:

The following steps are required:

* Initially take two pointers, fast and slow. The fast pointer takes two steps ahead while
  the slow pointer will take a single step ahead for each iteration.
* We know that if a cycle exists, fast and slow pointers will collide.
* If the cycle does not exist, the fast pointer will move to NULL
* Else, when both slow and fast pointer collides, it detects a cycle exists.
* Take another pointer, say entry. Point to the very first of the linked list.
* Move the slow and the entry pointer ahead by single steps until they collide.
* Once they collide we get the starting next of the linked list.

But why use another pointer, or xentry?

Let’s say a slow pointer covers the L2 distance from the starting next of the cycle until it
collides with a fast pointer. L1 is the distance traveled by the entry pointer to the
starting next of the cycle. So, in total, the slow pointer covers the L1+L2 distance.
We know that a fast pointer covers some steps more than a slow pointer. Therefore, we can
say that a fast pointer will surely cover the L1+L2 distance. Plus, a fast pointer will
cover more steps which will accumulate to nC length where cC is the length of the cycle
and n is the number of turns. Thus, the fast pointer covers the total length of L1+L2+nC.

We know that the slow pointer travels twice the fast pointer. So this makes the equation to

2(L1+L2) = L1+L2+nC. This makes the equation to

L1+L2 = nC. Moving L2 to the right side

L1 = nC-L2 and this shows why the entry pointer and the slow pointer would collide.


Dry Run:
We initialize fast and slow pointers to the head of the list. Fast moves two steps ahead
and slowly takes a single step ahead.

// Image

We can see that the fast and slow pointer collides which shows the cycle exists. The entry
pointer is pointed to the head of the list. And move them forward until it collides with
the slow pointer.

// Image

We see that both collide and hence, we get the starting next of the list.

Program :

public class OptimalApproach {

    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);
        if(head == null) {
            head = newNode;
            return head;
        }
        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    static void createCycle(ListNode head,int pos) {
        ListNode ptr = head;
        ListNode temp = head;
        int cnt = 0;
        while(temp.next != null) {
            if(cnt != pos) {
                ++cnt;
                ptr = ptr.next;
            }
            temp = temp.next;
        }
        temp.next = ptr;
    }

    public static void main(String[] args) {
        ListNode head = null;

        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);
        head=insertNode(head,3);
        head=insertNode(head,6);
        head=insertNode(head,10);

        createCycle(head,2);

        ListNode nodeReceive = detectNode(head);

        if(nodeReceive == null) {
            System.out.println("No Cycle Detect");
        }
        else {
            int pos = 0;
            while (nodeReceive != head) {
                head = head.next;
                pos++;
            }

            System.out.println("Cycle Detect At "+pos);
        }
    }

    static ListNode detectNode(ListNode head) {
        if(head == null || head.next == null) {
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;
        ListNode entry = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast) {
                while (slow != entry) {
                    slow = slow.next;
                    entry = entry.next;
                }
                return slow;
            }
        }

        return null;
    }
}

Output :
Cycle Detect At 2

Time Complexity: O(N)
Reason: We can take overall iterations and club them to O(N)

Space Complexity: O(1)
Reason: No extra data structure is used.

--------------------------------- XX ---------------------------------

Que 10 : Flattening a Linked List

Problem Statement: Given a Linked List of size N, where every next represents a sub-linked-list and
contains two pointers:
(i) a next pointer to the next next,
(ii) a bottom pointer to a linked list where this next is head.
Each of the sub-linked-list is in sorted order.
Flatten the Link List such that all the nodes appear in a single level while maintaining the sorted order.
Note: The flattened list will be printed using the bottom pointer instead of the next pointer.

Level : Medium

Link : https://takeuforward.org/data-structure/flattening-a-linked-list/

Example 1:
Input:
Number of head nodes = 4
Array holding length of each list with head and bottom = [4,2,3,4]
Elements of entire linked list = [5,7,8,30,10,20,19,22,50,28,35,40,45]

// Image

Output: Flattened list = [5,7,8,10,19,20,22,28,30,35,40,45,50]
Explanation: Flattened list is the linked list consisting entire elements of the given
list in sorted order

Example 2:
Input:
Number of head nodes = 4
Array holding length of each list with head and bottom = [4,1,3,1]
Elements of entire linked list = [5,7,8,30,10,19,22,50,28]

// Image

Output: Flattened list = [5,7,8,10,19,22,28,30,50]
Explanation: Flattened list is the linked list consisting entire elements of the given list
in sorted order

Solution:

Approach:

Since each list, followed by the bottom pointer, are in sorted order. Our main aim is to
make a single list in sorted order of all nodes. So, we can think of a merge algorithm of
merge sort.

The process to flatten the given linked list is as follows:-

* We will recurse until the head pointer moves null. The main motive is to merge each list
from the last.
* Merge each list chosen using the merge algorithm. The steps are
* Create a dummy next. Point two pointers, i.e, temp and res on dummy next. res is to keep
track of dummy next and temp pointer is to move ahead as we build the flattened list.
* We iterate through the two chosen. Move head from any of the chosen lists ahead whose
current pointed next is smaller.
* Return the new flattened list found.

Dry Run:

We will assign individual lists with bottom pointers names as l1, l2, l3, and l4
respectively for our convenience.

// Image

Let’s see the recursion tree of the function flatten and merge function. It will trace down to
allow the merge function to merge two sorted lists from the end.

// Image

The merge function works like the merge algorithm of merge sort. Firstly, the algorithm will
merge l3,l4 lists.

// Image

Now, pointer b is null. So, we will merge the remaining nodes of pointer a until next a reaches null.

// Image

The same way other pairs of lists will be merged.

Program :

public class FlattenLinkedList {
    static class Node {
        int data;
        Node next;
        Node bottom;

        Node(int d)
        {
            data = d;
            next = null;
            bottom = null;
        }
    }

    static Node insertNode(int data, Node head) {
        Node newNode = new Node(data);
        if(head == null) {
            return newNode;
        }

        Node temp = head;

        while (temp.bottom != null) {
            temp = temp.bottom;
        }

        temp.bottom = newNode;

        return head;
    }

    static void printList(Node head) {
        while (head.bottom != null) {
            System.out.print(head.data+"->");
            head = head.bottom;
        }
        System.out.print(head.data);
    }

    static Node createNodeList() {
        Node head = null;
        head = insertNode(5, head);
        head = insertNode(7, head);
        head = insertNode(8, head);
        head = insertNode(10, head);

        printList(head);

        System.out.println();

        Node head2 = null;
        head2 = insertNode(10, head2);
        head2 = insertNode(20, head2);

        printList(head2);

        System.out.println();

        Node head3 = null;
        head3 = insertNode(19, head3);
        head3 = insertNode(22, head3);
        head3 = insertNode(50, head3);

        printList(head3);

        System.out.println();

        Node head4 = null;
        head4 = insertNode(28, head4);
        head4 = insertNode(35, head4);
        head4 = insertNode(40, head4);
        head4 = insertNode(45, head4);

        printList(head4);

        System.out.println();

        head.next = head2;
        head2.next = head3;
        head3.next = head4;

        return head;
    }

    public static void main(String[] args) {
        Node head = createNodeList();

        Node flatterList = flatten(head);

        printList(flatterList);

        System.out.println();
    }

    static Node flatten(Node root) {
        if(root == null || root.next == null) {
            return root;
        }

        root.next = flatten(root.next);

        root = mergeTwoList(root, root.next);

        return root;
    }

    static Node mergeTwoList(Node a, Node b) {
        Node temp = new Node(0);
        Node res = temp;

        while (a != null && b != null) {
            if(a.data < b.data) {
                temp.bottom = a;
                temp = temp.bottom;
                a = a.bottom;
            }
            else {
                temp.bottom = b;
                temp = temp.bottom;
                b = b.bottom;
            }
        }

        if(a != null) {
            temp.bottom = a;
        }
        else {
            temp.bottom = b;
        }

        return res.bottom;
    }
}


Output :
5->7->8->10
10->20
19->22->50
28->35->40->45

5->7->8->10->10->19->20->22->28->35->40->45->50

Time Complexity: O(N), where N is the total number of nodes present
Reason: We are visiting all the nodes present in the given list.

Space Complexity: O(1)
Reason: We are not creating new nodes or using any other data structure.

--------------------------------- XX ---------------------------------

Que 11 : Rotate a Linked List
Problem Statement: Given the head of a linked list, rotate the list to the right by k places.
Level : Medium
Link : https://takeuforward.org/data-structure/rotate-a-linked-list/

Example 1:
Input:
	head = [1,2,3,4,5]
	k = 2
Output:
    head = [4,5,1,2,3]

Explanation:
    We have to rotate the list to the right twice.

// Image

Example 2:
Input:
	head = [1,2,3]
	k = 4
Output:
    head = [3,1,2]
Explanation:

// Image

Solution: Brute Force

Approach:

We have to move the last element to first for each k.
For each k, find the last element from the list. Move it to the first.

Program :

public class BruteForceApproach {
    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);
        if (head == null) {
            head = newNode;
            return head;
        }
        ListNode temp = head;
        while (temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    static void printList(ListNode head) {
        while (head.next != null) {
            System.out.print(head.val + "->");
            head = head.next;
        }
        System.out.println(head.val);

    }

    public static void main(String args[]) {
        ListNode head = null;
        //inserting ListNode
        head = insertNode(head, 1);
        head = insertNode(head, 2);
        head = insertNode(head, 3);
        head = insertNode(head, 4);
        head = insertNode(head, 5);

        System.out.println("Original list: ");
        printList(head);

        int k = 2;
        ListNode newHead = rotateRight(head, k); //calling function for rotating right of the nodes by k times

        System.out.println("After " + k + " iterations: ");
        printList(newHead); //list after rotating nodes
    }

    public static ListNode rotateRight(ListNode head, int k) {
        if(head == null || head.next == null) {
            return head;
        }

        for (int i = 0; i < k; i++) {
            ListNode temp = head;

            while (temp.next.next != null) {
                temp = temp.next;
            }

            ListNode end = temp.next;
            temp.next = null;
            end.next = head;

            head = end;
        }

        return head;
    }
}

Output :
Original list:
1->2->3->4->5
After 2 iterations:
4->5->1->2->3

Time Complexity: O(Number of nodes present in the list*k)
Reason: For k times, we are iterating through the entire list to get the last element and move it to first.

Space Complexity: O(1)
Reason: No extra data structures are used for computations


Solution: Optimal Solution
--------------------------

Approach:

Let’s take an example.

head = [1,2,3,4,5] k = 2000000000

If we see a brute force approach, it will take O(5*2000000000) which is not a good time complexity when we can
optimize it.

We can see that for every k which is multiple of the length of the list, we get back the original list. Try to
operate brute force on any linked list for k as a multiple of the length of the list.

This gives us a hint that for k greater than the length of the list, we have to rotate the list for k%length of
the list. This reduces our time complexity.

Steps to the algorithm:-

Calculate the length of the list.
Connect the last next to the first next, converting it to a circular linked list.
Iterate to cut the link of the last next and start a next of k%length of the list rotated list.

Dry Run:

Let’s calculate the length of the list by iterating on it until it reaches null and increasing the count. Once the
length is calculated we will connect the last next to the first next.

// Image

Now, the length of the list is 5 and k is 2. k is less than the length of the given list. So, we will have the head of
the rotating list at the kth element from the end remove the link from the length-k next from its next next and make
it NULL.

// Image

Thus, we received our desired output.

Program :

public class OptimalApproach {
    //utility function to insert ListNode at the end of the list
    static ListNode insertNode(ListNode head, int val) {
        ListNode newNode = new ListNode(val);
        if(head == null) {
            head = newNode;
            return head;
        }
        ListNode temp = head;
        while(temp.next != null) temp = temp.next;

        temp.next = newNode;
        return head;
    }

    //utility function to print list
    static void printList(ListNode head) {
        while(head.next != null) {
            System.out.print(head.val+"->");
            head = head.next;
        }
        System.out.println(head.val);

    }

    public static void main(String args[]) {
        ListNode head = null;
        //inserting ListNode
        head=insertNode(head,1);
        head=insertNode(head,2);
        head=insertNode(head,3);
        head=insertNode(head,4);
        head=insertNode(head,5);

        System.out.println("Original list: ");
        printList(head);

        int k = 3;
        ListNode newHead = rotateRight(head,k);//calling function for rotating right of the nodes by k times

        System.out.println("After "+k+" iterations: ");
        printList(newHead);//list after rotating nodes
    }

    static ListNode rotateRight(ListNode head, int k) {
        if(head == null || head.next == null || k == 0) {
            return head;
        }

        ListNode temp = head;
        int length = 1;

        while (temp.next != null) {
            length++;
            temp = temp.next;
        }

        temp.next = head;

        k = k % length;

        int end = length - k;

        while (end != 0) {
            end--;
            temp = temp.next;
        }

        head = temp.next;

        temp.next = null;

        return head;
    }
}

Time Complexity: O(length of list) + O(length of list – (length of list%k))
Reason: O(length of the list) for calculating the length of the list. O(length of the list – (length of list%k)) for breaking link.

Space Complexity: O(1)
Reason: No extra data structure is used for computation.

--------------------------------- XX ---------------------------------

Que 12 : Clone Linked List with Random and Next Pointer
Problem Statement: Given a Linked list that has two pointers in each next and one of which points to the first next and the
other points to any random next. Write a program to clone the LinkedList.
Level : Medium
Link : https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/

Example 1:
Input:
	head = [[1,3],[2,0],[3,null],[4,1]]
Output:
	head = [[1,3],[2,0],[3,null],[4,1]]
Explanation:

// Image

Example 2:
Input:
    head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output:
    head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Explanation:

// Image


Solution 1: Brute Force
Approach:
We will use a hash-map for keeping track of deep copies of every next.

* Iterate through the entire list.
* For each next, create a deep copy of each next and hash it with it. Store it in the hashmap.
* Now, again iterate through the given list. For each next, link the deep next present as the
  hash value of the original next as per original next.
* the head of the deep copy list will be the head of hashed value of original next.

Dry Run:
* We will iterate through the list. For each next, we will create its deep copy next and hash
  it with the current next.

(Not to confuse with new nodes created in the hash table, these nodes are represented by (‘))

// Image

Now we will iterate through the original list again. Since deep copies of each next are hashed
with the original next, we can access from original nodes and link them.

// Image

Hence, we achieved the deep copy of the original linked list accessible by the hashed value head
of the original list.

Program :

public class BruteForce {

    static class Node {
        int val;
        Node next;
        Node random;
        Node(int value) {
            val = value;
            next = null;
            random = null;
        }
    }

    static void printList(Node head) {
        while(head != null) {
            System.out.print(head.val+":");
            if(head.next != null)
                System.out.print(head.next.val);
            else
                System.out.print("NULL");
            if(head.random != null)
                System.out.print(","+head.random.val);
            else
                System.out.print(",NULL");
            System.out.println();
            head = head.next;
        }
    }

    public static void main(String[] args) {
        Node head = null;

        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);

        head = node1;
        head.next = node2;
        head.next.next = node3;
        head.next.next.next = node4;

        head.random = node4;
        head.next.random = node1;
        head.next.next.random = null;
        head.next.next.next.random = node2;

        System.out.println("Original list:(current next:next pointed by next pointer, next pointed by random pointer)");
        printList(head);

        System.out.println("Copy list:(current next:next pointed by next pointer,next pointed by random pointer)");
        Node newHead = copyRandomList(head);
        printList(newHead);
    }

    static Node copyRandomList(Node head) {
        HashMap<Node, Node> hashMap = new HashMap<>();
        Node temp = head;

        while (temp != null) {
            Node newNode = new Node(temp.val);
            hashMap.put(temp, newNode);

            temp = temp.next;
        }

        Node t = head;

        while (t != null) {
            Node next = hashMap.get(t);
            next.next = (t.next != null) ? hashMap.get(t.next) : null;
            next.random = (t.random != null) ? hashMap.get(t.random) : null;

            t = t.next;
        }

        return hashMap.get(head);
    }
}


Output :
Original list:(current next:next pointed by next pointer, next pointed by random pointer)
1:2,4
2:3,1
3:4,NULL
4:NULL,2
Copy list:(current next:next pointed by next pointer,next pointed by random pointer)
1:2,4
2:3,1
3:4,NULL
4:NULL,2

Time Complexity: O(N)+O(N)
Reason: Two iterations over the entire list. Once for inserting in the map and other for
linking nodes with next and random pointer.

Space Complexity: O(N)
Reason: Use of hashmap for storing entire data.

Solution 2: Optimized
---------------------

Approach:
The optimisation will be in removing the extra spaces, i.e, the hashmap used in brute force.
This approach can be broken down into three steps.

* Create deep nodes of all nodes. Instead of storing these nodes in a hashmap, we will point
  it to the next of the original nodes.
* Take a pointer, say itr, point it to the head of the list. This will help us to point random
  pointers as per the original list. This can be achieved by
  itr->next->random = itr->random->next
* Use three pointers. One dummy next whose next next points to the first deep next. itr pointer
  at the head of the original list and fast which is two steps ahead of the itr. This will be
  used to separate the original linked list with the deep nodes list.

Dry Run:
In brute force, we created new nodes and stored them in the hashmap. Here, we will create each
next and link it next to the original nodes. This contributes to step1. (Blue colored nodes
are deep copy nodes)

// Image

In step 2, we use a pointer itr. This pointer will help to create random pointer links among
deep copy nodes. (Purple color lines show itr->next->random. Red color lines shows itr->random->next)

// Image

Since this next’s random pointer is pointing to NULL. Therefore, highlighted arrows are not present.

// Image

Our task is to differentiate the original list and deep copy one.

// Image

Finally returning dummy->next we get our desired answer.

// Image

Program :

public class OptimalApproach {

    static class Node {
        int val;
        Node next;
        Node random;
        Node(int value) {
            val = value;
            next = null;
            random = null;
        }
    }

    static void printList(Node head) {
        while(head != null) {
            System.out.print(head.val+":");
            if(head.next != null)
                System.out.print(head.next.val);
            else
                System.out.print("NULL");
            if(head.random != null)
                System.out.print(","+head.random.val);
            else
                System.out.print(",NULL");
            System.out.println();
            head = head.next;
        }
    }

    public static void main(String[] args) {
        Node head = null;

        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);

        head = node1;
        head.next = node2;
        head.next.next = node3;
        head.next.next.next = node4;

        head.random = node4;
        head.next.random = node1;
        head.next.next.random = null;
        head.next.next.next.random = node2;

        System.out.println("Original list:(current next:next pointed by next pointer, next pointed by random pointer)");
        printList(head);

        System.out.println("Copy list:(current next:next pointed by next pointer,next pointed by random pointer)");
        Node newHead = copyRandomList(head);
        printList(newHead);
    }

    static Node copyRandomList(Node head) {
        Node temp = head;

        while(temp != null) {
            Node newNode = new Node(temp.val);
            newNode.next = temp.next;
            temp.next = newNode;
            temp = temp.next.next;
        }

        Node itr = head;

        while (itr != null) {
            if(itr.random != null) {
                itr.next.random = itr.random.next;
            }

            itr = itr.next.next;
        }

        Node dummy = new Node(0);
        itr = head;
        temp = dummy;
        Node fast;

        while (itr != null) {
            fast = itr.next.next;
            temp.next = itr.next;
            itr.next = fast;
            temp = temp.next;
            itr = fast;
        }

        return dummy.next;
    }
}

Output :

Original list:(current next:next pointed by next pointer, next pointed by random pointer)
1:2,4
2:3,1
3:4,NULL
4:NULL,2
Copy list:(current next:next pointed by next pointer,next pointed by random pointer)
1:2,4
2:3,1
3:4,NULL
4:NULL,2

Time Complexity: O(N)+O(N)+O(N)
Reason: Each step takes O(N) of time complexity.

Space Complexity: O(1)
Reason: No extra data structure was used for computation.

--------------------------------- XX ---------------------------------

Que 13 : 3 Sum : Find triplets that add up to a zero
Problem Statement: Given an array of N integers, your task is to find unique triplets that add
up to give a sum of zero. In short, you need to return an array of all the unique triplets
[arr[a], arr[b], arr[c]] such that i!=j, j!=k, k!=i, and their sum is equal to zero.
Level : Medium
Link : https://takeuforward.org/data-structure/3-sum-find-triplets-that-add-up-to-a-zero/

Brute Force Approach
--------------------

Algorithm / Intuition
In the question, it is clearly stated that for each case the picked indices i.e. i, j, and k
must be distinct. This means [arr[1], arr[1], arr[2]] is not a valid triplet and also remember
[arr[1], arr[0], arr[2]] and [arr[0], arr[1], arr[2]] will be considered the same.

Intuition:
This approach is pretty straightforward. Here, we will check all possible triplets using 3 loops
and among them, we will consider the ones whose sum is equal to the given target i.e. 0. And
before considering them as our answer we need to sort the triplets in ascending order so that
we can consider only the unique ones.

Algorithm:
The steps are as follows:

1. First, we will declare a set data structure as we want unique triplets.
2. Then we will use the first loop(say i) that will run from 0 to n-1.
3. Inside it, there will be the second loop(say j) that will run from i+1 to n-1.
4. Then there will be the third loop(say k) that runs from j+1 to n-1.
5. Now, inside these 3 nested loops, we will check the sum i.e. arr[i]+arr[j]+arr[k], and if it
   is equal to the target i.e. 0 we will sort this triplet and insert it in the set data
   structure.
6. Finally, we will return the list of triplets stored in the set data structure.

Note: For a better understanding of intuition, please watch the video at the bottom of the page.

Program :
public class BruteForce {
    public static void main(String[] args) {
        int[] arr = { -1, 0, 1, 2, -1, -4};
        int n = arr.length;
        List<List<Integer>> ans = triplet(n, arr);
        for (List<Integer> it : ans) {
            System.out.print("[");
            for (Integer i : it) {
                System.out.print(i + " ");
            }
            System.out.print("] ");
        }
        System.out.println();
    }

    static List<List<Integer>> triplet(int n, int[] arr) {
        HashSet<List<Integer>> hashSet = new HashSet<>();

        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                for (int k = j+1; k < n; k++) {
                    if(arr[i] + arr[j] + arr[k] == 0) {
                        List<Integer> temp = Arrays.asList(arr[i], arr[j], arr[k]);
                        temp.sort(null);
                        hashSet.add(temp);
                    }
                }
            }
        }

        List<List<Integer>> ans = new ArrayList<>(hashSet);
        return ans;
    }
}

Output :
[-1 -1 2 ] [-1 0 1 ]

Complexity Analysis

Time Complexity: O(N3 * log(no. of unique triplets)), where N = size of the array.
Reason: Here, we are mainly using 3 nested loops. And inserting triplets into the set takes
O(log(no. of unique triplets)) time complexity. But we are not considering the time complexity
of sorting as we are just sorting 3 elements every time.

Space Complexity: O(2 * no. of the unique triplets) as we are using a set data structure and a
list to store the triplets.

Better Approach
---------------

Algorithm / Intuition
Intuition:
In the previous approach, we utilized 3 loops, but now our goal is to reduce it to 2 loops.
To achieve this, we need to find a way to calculate arr[k] since we intend to eliminate the
third loop (k loop). To calculate arr[k], we can derive a formula as follows:

arr[k] = target – (arr[i]+arr[j]+arr[k]) = 0-(arr[i]+arr[j]+arr[k]) = -(arr[i]+arr[j]+arr[k])

So, we will first calculate arr[i] and arr[j] using 2 loops and for the third one i.e. arr[k]
we will not use another loop and instead we will look up the value 0-(arr[i]+arr[j]+arr[k])
in the set data structure. Thus we can remove the third loop from the algorithm.

For implementing the search operation of the third element,  we will store all the elements
between the indices i and j in a HashSet and then we will search for the third element in the
HashSet.

Why we are not inserting all the array elements in the HashSet and then searching for the third
element:

Let’s understand this intuition using an example. Assume the given array is {1, 2, -1, -2, 4, 0, -1}
and the target = 0. Now, we will notice a situation like the following:

// Image

Here, arr[i] = -2 and arr[j] = 4.
Therefore, arr[k] = -(arr[i]+arr[j]) = -(-2+4) = -2

* If all the elements were in the set data structure while searching for -2, we would again pick
  the element at index 3, that is currently pointed by i.
* Hence, the triplet will be [arr[i], arr[j], arr[i]]. And this is an invalid triplet. That is why
  we cannot insert all the elements into the set data structure.

Algorithm:
The steps are as follows:

* First, we will declare a set data structure as we want unique triplets.
* Then we will use the first loop(say i) that will run from 0 to n-1.
* Inside it, there will be the second loop(say j) that will run from i+1 to n-1.
* Before the second loop, we will declare another HashSet to store the array elements as we
  intend to search for the third element using this HashSet.
* Inside the second loop, we will calculate the value of the third element i.e. -(arr[i]+arr[j]).
* If the third element exists in the HashSet, we will sort these 3 values i.e. arr[i], arr[j],
  and the third element, and insert it in the set data structure declared in step 1.
* After that, we will insert the j-th element i.e. arr[j] in the HashSet as we only want to
  insert those array elements that are in between indices i and j.
* Finally, we will return a list of triplets stored in the set data structure.

Program :

public class BetterApproach {
    public static void main(String[] args) {
        int[] arr = { -1, 0, 1, 2, -1, -4};
        int n = arr.length;
        List<List<Integer>> ans = triplet(n, arr);
        for (List<Integer> it : ans) {
            System.out.print("[");
            for (Integer i : it) {
                System.out.print(i + " ");
            }
            System.out.print("] ");
        }
        System.out.println();
    }

    static List<List<Integer>> triplet(int n, int[] arr) {
        Set<List<Integer>> st = new HashSet<>();

        for (int i = 0; i < n; i++) {
            Set<Integer> hashSet = new HashSet<>();
            for (int j = i+1; j < n; j++) {
                int third = -(arr[i] + arr[j]);

                if(hashSet.contains(third)) {
                    List<Integer> temp = Arrays.asList(arr[i], arr[j], third);
                    temp.sort(null);
                    st.add(temp);
                }
                hashSet.add(arr[j]);
            }
        }

        List<List<Integer>> ans = new ArrayList<>(st);
        return ans;
    }
}

Output :
[-1 -1 2 ] [-1 0 1 ]

Complexity Analysis
Time Complexity: O(N2 * log(no. of unique triplets)), where N = size of the array.
Reason: Here, we are mainly using 3 nested loops. And inserting triplets into the set takes
O(log(no. of unique triplets)) time complexity. But we are not considering the time complexity
of sorting as we are just sorting 3 elements every time.

Space Complexity: O(2 * no. of the unique triplets) + O(N) as we are using a set data structure
and a list to store the triplets and extra O(N) for storing the array elements in another set.


Optimal Approach :
------------------

Algorithm / Intuition
In this approach, we intend to get rid of two things i.e. the HashSet we were using for the look-up
operation and the set data structure used to store the unique triplets.

So, We will first sort the array. Then, we will fix a pointer i, and the rest 2 pointers j and k will
be moving.

Now, we need to first understand what the HashSet and the set were doing to make our algorithm work
without them. So, the set data structure was basically storing the unique triplets in sorted order
and the HashSet was used to search for the third element.

That is why, we will first sort the entire array, and then to get the unique triplets, we will simply
skip the duplicate numbers while moving the pointers.

How to skip duplicate numbers:
As the entire array is sorted, the duplicate numbers will be in consecutive places. So, while moving a pointer,
we will check the current element and the adjacent element. Until they become different, we will move the
pointer by 1 place. We will follow this process for all 3 pointers. Thus, we can easily skip the duplicate
elements while moving the pointers.

Now, we can also remove the HashSet as we have two moving pointers i.e. j and k that will find the appropriate
value of arr[j] and arr[k]. So, we do not need that HashSet anymore for the look-up operations.

The process will look like the following:

// Image

Among the 3 pointers, 1 will be fixed and 2 will be moving. In each iteration, we will check if the sum
i.e.arr[i]+arr[j]+arr[k] is equal to the target i.e. 0.

* If the sum is greater, then we need lesser elements and so we will decrease the value of k(i.e. k–).
* If the sum is lesser than the target, we need a bigger value and so we will increase the value of j (i.e. j++).
* If the sum is equal to the target, we will simply insert the triplet i.e. arr[i], arr[j], arr[k], into our
  answer and move the pointers j and k skipping the duplicate elements.
Approach:
The steps are as follows:

* First, we will sort the entire array.
* We will use a loop(say i) that will run from 0 to n-1. This i will represent the fixed pointer. In each iteration,
  this value will be fixed for all different values of the rest of the 2 pointers. Inside the loop, we will first
  check if the current and the previous element is the same and if it is we will do nothing and continue to the
  next value of i.
* After that, there will be 2 moving pointers i.e. j(starts from i+1) and k(starts from the last index). The
  pointer j will move forward and the pointer k will move backward until they cross each other while the value
  of i will be fixed.

    1. Now we will check the sum i.e. arr[i]+arr[j]+arr[k].
    2. If the sum is greater, then we need lesser elements and so we will decrease the value of k(i.e. k–).
    3. If the sum is lesser than the target, we need a bigger value and so we will increase the value of j (i.e. j++).
    4. If the sum is equal to the target, we will simply insert the triplet i.e. arr[i], arr[j], arr[k] into our
    answer and move the pointers j and k skipping the duplicate elements(i.e. by checking the adjacent elements while
    moving the pointers).
* Finally, we will have a list of unique triplets.

Program :

public class OptimalApproach {
    public static void main(String[] args) {
        int[] arr = { -1, 0, 1, 2, -1, -4};
        int n = arr.length;
        List<List<Integer>> ans = triplet(n, arr);
        for (List<Integer> it : ans) {
            System.out.print("[");
            for (Integer i : it) {
                System.out.print(i + " ");
            }
            System.out.print("] ");
        }
        System.out.println();
    }

    static List<List<Integer>> triplet(int n, int[] arr) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(arr);

        for (int i = 0; i < n; i++) {
            if(i != 0 && arr[i] == arr[i-1]) continue;

            int j = i + 1;
            int k = n - 1;

            while (j < k) {
                int sum = arr[i] + arr[j] + arr[k];

                if(sum < 0) {
                    j++;
                }
                else if(sum > 0) {
                    k--;
                }
                else {
                    List<Integer> temp = Arrays.asList(arr[i], arr[j], arr[k]);
                    ans.add(temp);
                    j++;
                    k--;

                    while (j < k && arr[j] == arr[j - 1]) {
                        j++;
                    }
                    while (j < k && arr[k] == arr[k + 1]) {
                        k--;
                    }
                }
            }
        }

        return ans;
    }
}

Output :
[-1 -1 2 ] [-1 0 1 ]

Complexity Analysis

Time Complexity: O(NlogN)+O(N2), where N = size of the array.
Reason: The pointer i, is running for approximately N times. And both the pointers j and k combined can run
for approximately N times including the operation of skipping duplicates. So the total time complexity will
be O(N2).

Space Complexity: O(no. of quadruplets), This space is only used to store the answer. We are not using any
extra space to solve this problem. So, from that perspective, space complexity can be written as O(1).

--------------------------------- XX ---------------------------------